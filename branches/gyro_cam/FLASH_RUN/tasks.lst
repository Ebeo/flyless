   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"tasks.c"
  21              	.Ltext0:
  22              		.cfi_sections	.debug_frame
  23              		.section	.text.prvListTaskWithinSingleList,"ax",%progbits
  24              		.align	1
  25              		.thumb
  26              		.thumb_func
  28              	prvListTaskWithinSingleList:
  29              	.LFB32:
  30              		.file 1 "firmware/FreeRTOSV6.1.0/Source/tasks.c"
   1:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
   2:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     FreeRTOS V6.1.0 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
   4:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     ***************************************************************************
   5:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     *                                                                         *
   6:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     * If you are:                                                             *
   7:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     *                                                                         *
   8:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     *    + New to FreeRTOS,                                                   *
   9:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     *    + Looking for basic training,                                        *
  11:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     *                                                                         *
  13:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     * then take a look at the FreeRTOS books - available as PDF or paperback  *
  14:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     *                                                                         *
  15:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     *                                                                         *
  18:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     * exceptional circumstances).  Thank you for your support!                *
  22:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     *                                                                         *
  23:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     ***************************************************************************
  24:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  25:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  27:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     FreeRTOS WEB site.
  41:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  42:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     1 tab == 4 spaces!
  43:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  44:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     contact details.
  46:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  47:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     critical systems.
  49:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  50:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:firmware/FreeRTOSV6.1.0/Source/tasks.c ****     licensing and training services.
  52:firmware/FreeRTOSV6.1.0/Source/tasks.c **** */
  53:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  54:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  55:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #include <stdio.h>
  56:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #include <stdlib.h>
  57:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #include <string.h>
  58:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  59:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:firmware/FreeRTOSV6.1.0/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:firmware/FreeRTOSV6.1.0/Source/tasks.c **** task.h is included from an application file. */
  62:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  64:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #include "FreeRTOS.h"
  65:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #include "task.h"
  66:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #include "StackMacros.h"
  67:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  68:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  69:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  70:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
  71:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  72:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
  73:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  74:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  75:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
  76:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  77:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * and stores the context of the task.
  78:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
  79:firmware/FreeRTOSV6.1.0/Source/tasks.c **** typedef struct tskTaskControlBlock
  80:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
  81:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  82:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  83:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  84:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  85:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif	
  86:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	
  87:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  88:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  89:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  90:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  91:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  92:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  93:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  94:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  95:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
  96:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
  97:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  98:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
  99:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
 100:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 101:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 102:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 103:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
 104:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 105:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 106:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 107:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
 108:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 109:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 110:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 111:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
 112:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 113:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 114:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 115:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
 116:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 117:firmware/FreeRTOSV6.1.0/Source/tasks.c **** } tskTCB;
 118:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 119:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 120:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 121:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 122:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * than file scope.
 123:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 124:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 125:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#define static
 126:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 127:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 128:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*lint -e956 */
 129:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 130:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 131:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 132:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 133:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 134:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 135:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 136:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 137:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 138:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 139:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 140:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 141:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 142:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	PRIVILEGED_DATA static volatile xList xTasksWaitingTermination;		/*< Tasks that have been deleted 
 143:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 144:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 145:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 146:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 147:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 148:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 149:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 150:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 151:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 152:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 153:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /* File private variables. --------------------------------*/
 154:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 155:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0;
 156:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 157:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 158:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 159:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 160:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 161:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 162:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 163:firmware/FreeRTOSV6.1.0/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0;
 164:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 165:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 166:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 167:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 168:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 169:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 170:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 171:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 172:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 173:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 174:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 175:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 176:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 177:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 178:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 179:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5 )
 180:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 181:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 182:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 183:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 184:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 185:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 186:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 187:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 188:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 189:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 190:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Macros and private variables used by the trace facility.
 191:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 192:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 193:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 194:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 195:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 196:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 197:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 198:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 199:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	static unsigned portBASE_TYPE uxPreviousTask = 255;
 200:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 201:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 202:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 203:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 204:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
 205:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 206:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 207:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 208:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * shows which task is running when and is very useful as a debugging tool.
 209:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * As this macro is called each context switch it is a good idea to undefine
 210:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * it if not using the facility.
 211:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 212:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 213:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 214:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#define vWriteTraceToBuffer()																	\
 215:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{																								\
 216:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTracing )																				\
 217:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{																							\
 218:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
 219:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{																						\
 220:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
 221:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{																					\
 222:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
 223:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;		\
 224:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );									\
 225:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;	\
 226:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );									\
 227:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}																					\
 228:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				else																				\
 229:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{																					\
 230:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					xTracing = pdFALSE;																\
 231:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}																					\
 232:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}																						\
 233:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}																							\
 234:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 235:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 236:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #else
 237:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 238:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#define vWriteTraceToBuffer()
 239:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 240:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 241:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
 242:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 243:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 244:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 245:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 246:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 247:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 248:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * executing task has been rescheduled.
 249:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 250:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																			\
 251:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {																												\
 252:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( pxTCB->uxPriority > uxTopReadyPriority )																\
 253:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{																											\
 254:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		uxTopReadyPriority = pxTCB->uxPriority;																	\
 255:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}																											\
 256:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListIte
 257:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 258:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
 259:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 260:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 261:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 262:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * any require waking.
 263:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *
 264:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 265:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 266:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * any further down the list.
 267:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 268:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #define prvCheckDelayedTasks()																						\
 269:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {																													\
 270:firmware/FreeRTOSV6.1.0/Source/tasks.c **** register tskTCB *pxTCB;																								\
 271:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 																													\
 272:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ) ) != NULL )						\
 273:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{																												\
 274:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTickCount < listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) ) )									\
 275:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{																											\
 276:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			break;																									\
 277:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}																											\
 278:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vListRemove( &( pxTCB->xGenericListItem ) );																\
 279:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Is the task waiting on an event also? */																	\
 280:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( pxTCB->xEventListItem.pvContainer )																		\
 281:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{																											\
 282:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListRemove( &( pxTCB->xEventListItem ) );																\
 283:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}																											\
 284:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxTCB );																			\
 285:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}																												\
 286:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 287:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
 288:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 289:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 290:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 291:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 292:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 293:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 294:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 295:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( pxHandle == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskT
 296:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 297:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 298:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /* File private functions. --------------------------------*/
 299:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 300:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 301:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 302:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * into the TCB structure.
 303:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 304:firmware/FreeRTOSV6.1.0/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 305:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 306:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 307:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 308:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * automatically upon the creation of the first task.
 309:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 310:firmware/FreeRTOSV6.1.0/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 311:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 312:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 313:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 314:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 315:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * creation of the first user task.
 316:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *
 317:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 318:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 319:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *
 320:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 321:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *
 322:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 323:firmware/FreeRTOSV6.1.0/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 324:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 325:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 326:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 327:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * including the stack pointed to by the TCB.
 328:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *
 329:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 330:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 331:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 332:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
 333:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 334:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 335:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 336:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 337:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 338:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 339:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 340:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 341:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * and its TCB deleted.
 342:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 343:firmware/FreeRTOSV6.1.0/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 344:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 345:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 346:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 347:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * allocation was successful.
 348:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 349:firmware/FreeRTOSV6.1.0/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 350:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 351:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 352:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 353:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 354:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 355:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * within just that list.
 356:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *
 357:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 358:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 359:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 360:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 361:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 362:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 363:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 364:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 365:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 366:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
 367:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 368:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 369:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 370:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
 371:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 372:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 373:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 374:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 375:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 376:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 377:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 378:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*lint +e956 */
 379:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 380:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 381:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 382:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------
 383:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * TASK CREATION API documented in task.h
 384:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *----------------------------------------------------------*/
 385:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 386:firmware/FreeRTOSV6.1.0/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 387:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 388:firmware/FreeRTOSV6.1.0/Source/tasks.c **** signed portBASE_TYPE xReturn;
 389:firmware/FreeRTOSV6.1.0/Source/tasks.c **** tskTCB * pxNewTCB;
 390:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 391:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 392:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	checking that the allocation was successful. */
 393:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 394:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 395:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( pxNewTCB != NULL )
 396:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 397:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 398:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 399:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 400:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 401:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 402:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0x00 )
 403:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 404:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 405:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 406:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			else
 407:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 408:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 409:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 410:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 411:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 412:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 413:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 414:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 415:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 416:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		required by the port. */
 417:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 418:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 419:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 420:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~
 421:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 422:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#else
 423:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 424:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 425:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 426:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 427:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 428:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			other extreme of the stack space. */
 429:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 430:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 431:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#endif
 432:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 433:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 434:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 435:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 436:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 437:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 438:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 439:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		the	top of stack variable is updated. */
 440:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 441:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 442:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 443:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 444:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#else
 445:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 446:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 447:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 448:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#endif
 449:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 450:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 451:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 452:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 453:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 454:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			required.*/
 455:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 456:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 457:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		
 458:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 459:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 460:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
 461:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 462:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 463:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 464:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 465:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 466:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				the suspended state - make this the current task. */
 467:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 468:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 469:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 470:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 471:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 472:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 473:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					fails, but we will report the failure. */
 474:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvInitialiseTaskLists();
 475:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 476:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 477:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			else
 478:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 479:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 480:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				current task if it is the highest priority task to be created
 481:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				so far. */
 482:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 483:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 484:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 485:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					{
 486:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 487:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					}
 488:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 489:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 490:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 491:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 492:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 493:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 494:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 495:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 496:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 497:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 498:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 499:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 500:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 501:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 502:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 503:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#endif
 504:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxTaskNumber++;
 505:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 506:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 507:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 508:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xReturn = pdPASS;
 509:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 510:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 511:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
 512:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 513:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	else
 514:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 515:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 516:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		traceTASK_CREATE_FAILED( pxNewTCB );
 517:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 518:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 519:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( xReturn == pdPASS )
 520:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 521:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 522:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 523:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 524:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			then it should run now. */
 525:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 526:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 527:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				portYIELD_WITHIN_API();
 528:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 529:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 530:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 531:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 532:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	return xReturn;
 533:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 534:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
 535:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 536:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 537:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 538:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 539:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 540:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tskTCB *pxTCB;
 541:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 542:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
 543:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 544:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 545:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			deleted. */
 546:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 547:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 548:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				pxTaskToDelete = NULL;
 549:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 550:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 551:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 552:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 553:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 554:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 555:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 556:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 557:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			scheduler for the TCB and stack. */
 558:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 559:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 560:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 561:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 562:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 563:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 564:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 565:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 566:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 567:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 568:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 569:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 570:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 571:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			++uxTasksDeleted;
 572:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 573:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 574:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 575:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxTaskNumber++;
 576:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 577:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 578:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 579:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
 580:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 581:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 582:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 583:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 584:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 585:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 586:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				portYIELD_WITHIN_API();
 587:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 588:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 589:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 590:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 591:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 592:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 593:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 594:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 595:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 596:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 597:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 598:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------
 599:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 600:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *----------------------------------------------------------*/
 601:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 602:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 603:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 604:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 605:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 606:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portTickType xTimeToWake;
 607:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 608:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 609:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vTaskSuspendAll();
 610:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 611:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 612:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 613:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 614:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 615:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 616:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 617:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 618:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 619:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 620:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 621:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 622:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 623:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 624:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 625:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 626:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			else
 627:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 628:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 629:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 630:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				tick time is less than the wake time. */
 631:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 632:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 633:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 634:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 635:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 636:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 637:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 638:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 639:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 640:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( xShouldDelay )
 641:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 642:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 643:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 644:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 645:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 646:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				both lists. */
 647:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 648:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 649:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* The list item will be inserted in wake time order. */
 650:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 651:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 652:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 653:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 654:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* Wake time has overflowed.  Place this item in the
 655:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					overflow list. */
 656:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 657:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 658:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				else
 659:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 660:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* The wake time has not overflowed, so we can use the
 661:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					current block list. */
 662:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 663:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 664:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 665:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 666:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 667:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 668:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 669:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		have put ourselves to sleep. */
 670:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( !xAlreadyYielded )
 671:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 672:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			portYIELD_WITHIN_API();
 673:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 674:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 675:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 676:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 677:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
 678:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 679:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 680:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 681:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 682:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 683:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portTickType xTimeToWake;
 684:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 685:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 686:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 687:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0 )
 688:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 689:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vTaskSuspendAll();
 690:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 691:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				traceTASK_DELAY();
 692:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 693:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* A task that is removed from the event list while the
 694:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 695:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 696:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				is resumed.
 697:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 698:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 699:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				executing task. */
 700:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 701:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 702:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				not a problem. */
 703:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 704:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 705:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 706:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 707:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				both lists. */
 708:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 709:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 710:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* The list item will be inserted in wake time order. */
 711:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 712:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 713:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 714:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 715:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* Wake time has overflowed.  Place this item in the
 716:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					overflow list. */
 717:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 718:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 719:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				else
 720:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 721:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* The wake time has not overflowed, so we can use the
 722:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					current block list. */
 723:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 724:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 725:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 726:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 727:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 728:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 729:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 730:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		have put ourselves to sleep. */
 731:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( !xAlreadyYielded )
 732:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 733:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			portYIELD_WITHIN_API();
 734:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 735:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 736:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 737:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 738:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
 739:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 740:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 741:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 742:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 743:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 744:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tskTCB *pxTCB;
 745:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 746:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 747:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
 748:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 749:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 750:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			priority of the calling function. */
 751:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 752:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 753:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 754:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
 755:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 756:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		return uxReturn;
 757:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 758:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 759:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 760:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
 761:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 762:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 763:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 764:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 765:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 766:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tskTCB *pxTCB;
 767:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority, xYieldRequired = pdFALSE;
 768:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 769:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 770:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 771:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 772:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - 1;
 773:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 774:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 775:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
 776:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 777:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 778:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 779:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				pxTask = NULL;
 780:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 781:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 782:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 783:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			priority of the calling function. */
 784:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 785:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 786:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 787:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 788:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 789:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 790:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 791:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 792:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#else
 793:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 794:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 795:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 796:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#endif
 797:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 798:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 799:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 800:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 801:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				priority than the calling task. */
 802:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 803:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 804:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					if( pxTask != NULL )
 805:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					{
 806:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 807:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						were raising the priority of the currently running task
 808:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						there would be no need to switch as it must have already
 809:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						been the highest priority task. */
 810:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 811:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					}
 812:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 813:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				else if( pxTask == NULL )
 814:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 815:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 816:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 817:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 818:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 819:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 820:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 821:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 822:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 823:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 824:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 825:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					currently using an inherited priority. */
 826:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 827:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					{
 828:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 829:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					}
 830:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 831:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* The base priority gets set whatever. */
 832:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 833:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 834:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				#else
 835:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 836:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 837:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 838:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				#endif
 839:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 840:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 841:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 842:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 843:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 844:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 845:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				in the queue appropriate to its new priority. */
 846:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 847:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 848:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 849:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 850:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 851:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 852:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 853:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 854:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 855:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 856:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 857:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					portYIELD_WITHIN_API();
 858:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 859:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 860:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 861:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
 862:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 863:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 864:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 865:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
 866:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 867:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 868:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 869:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 870:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 871:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tskTCB *pxTCB;
 872:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 873:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
 874:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 875:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 876:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			suspended. */
 877:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 878:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 879:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 880:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 881:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 882:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 883:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 884:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 885:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 886:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 887:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 888:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 889:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 890:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 891:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 892:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 893:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 894:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 895:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 896:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 897:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 898:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
 899:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 900:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 901:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 902:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 903:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 904:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* We have just suspended the current task. */
 905:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				portYIELD_WITHIN_API();
 906:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 907:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			else
 908:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 909:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 910:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 911:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				must be adjusted to point to a different task. */
 912:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == 1 )
 913:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 914:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* No other tasks are defined, so set pxCurrentTCB back to
 915:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 916:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					be set to point to it no matter what its relative priority
 917:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					is. */
 918:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					pxCurrentTCB = NULL;
 919:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 920:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				else
 921:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 922:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vTaskSwitchContext();
 923:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 924:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 925:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 926:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 927:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 928:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 929:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
 930:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 931:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 932:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 933:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 934:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 935:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 936:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 937:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 938:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 939:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		suspended list? */
 940:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 941:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 942:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 943:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 944:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 945:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 946:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 947:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				list because it is blocked on a task with no timeout
 948:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				specified. */
 949:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 950:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 951:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					xReturn = pdTRUE;
 952:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 953:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 954:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 955:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 956:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		return xReturn;
 957:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 958:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 959:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
 960:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
 961:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 962:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 963:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 964:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 965:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 966:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tskTCB *pxTCB;
 967:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 968:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 969:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		it in the ready list. */
 970:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 971:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 972:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 973:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		currently executing task. */
 974:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 975:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
 976:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			portENTER_CRITICAL();
 977:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
 978:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 979:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
 980:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
 981:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 982:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
 983:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					lists even if the scheduler is suspended. */
 984:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 985:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 986:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
 987:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
 988:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 989:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					{
 990:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
 991:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
 992:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						portYIELD_WITHIN_API();
 993:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					}
 994:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
 995:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
 996:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			portEXIT_CRITICAL();
 997:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
 998:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 999:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1000:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
1001:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1002:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1003:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1004:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1005:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1006:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1007:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1008:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
1009:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tskTCB *pxTCB;
1010:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1011:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
1012:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1013:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1014:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1015:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
1016:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1017:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1018:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1019:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
1020:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
1021:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
1022:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1023:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			else
1024:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1025:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* We cannot access the delayed or ready lists, so will hold this
1026:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				task pending until the scheduler is resumed, at which point a
1027:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				yield will be performed if necessary. */
1028:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1029:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1030:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1031:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1032:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		return xYieldRequired;
1033:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1034:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1035:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
1036:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1037:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1038:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1039:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1040:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------
1041:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1042:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *----------------------------------------------------------*/
1043:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1044:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1045:firmware/FreeRTOSV6.1.0/Source/tasks.c **** void vTaskStartScheduler( void )
1046:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1047:firmware/FreeRTOSV6.1.0/Source/tasks.c **** portBASE_TYPE xReturn;
1048:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1049:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1050:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
1051:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1052:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( xReturn == pdPASS )
1053:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1054:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1055:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1056:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1057:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1058:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		starts to run.
1059:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1060:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1061:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1062:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1063:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1064:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1065:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xTickCount = ( portTickType ) 0;
1066:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1067:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1068:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1069:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		the run time counter time base. */
1070:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1071:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1072:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1073:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portable interface. */
1074:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xPortStartScheduler() )
1075:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1076:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1077:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			function will not return. */
1078:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1079:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		else
1080:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1081:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1082:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1083:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1084:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1085:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1086:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1087:firmware/FreeRTOSV6.1.0/Source/tasks.c **** void vTaskEndScheduler( void )
1088:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1089:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1090:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1091:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1092:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1093:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
1094:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vPortEndScheduler();
1095:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1096:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*----------------------------------------------------------*/
1097:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1098:firmware/FreeRTOSV6.1.0/Source/tasks.c **** void vTaskSuspendAll( void )
1099:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1100:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1101:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portBASE_TYPE. */
1102:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	++uxSchedulerSuspended;
1103:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1104:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*----------------------------------------------------------*/
1105:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1106:firmware/FreeRTOSV6.1.0/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1107:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1108:firmware/FreeRTOSV6.1.0/Source/tasks.c **** register tskTCB *pxTCB;
1109:firmware/FreeRTOSV6.1.0/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
1110:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1111:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1112:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1113:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1114:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1115:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1116:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portENTER_CRITICAL();
1117:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1118:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		--uxSchedulerSuspended;
1119:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1120:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1121:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1122:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
1123:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1124:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
1125:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1126:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1127:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				appropriate ready list. */
1128:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
1129:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
1130:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
1131:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1132:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1133:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1134:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1135:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					the current task then we should yield. */
1136:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1137:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					{
1138:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1139:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					}
1140:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
1141:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1142:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1143:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1144:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1145:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
1146:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
1147:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
1148:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					{
1149:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						vTaskIncrementTick();
1150:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						--uxMissedTicks;
1151:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					}
1152:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1153:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1154:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1155:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					the task actually running. */
1156:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1157:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					{
1158:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1159:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					}
1160:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					#endif
1161:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
1162:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1163:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
1164:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
1165:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
1166:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					xMissedYield = pdFALSE;
1167:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					portYIELD_WITHIN_API();
1168:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
1169:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1170:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1171:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1172:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portEXIT_CRITICAL();
1173:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1174:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	return xAlreadyYielded;
1175:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1176:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1177:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1178:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1179:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1180:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1181:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1182:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------
1183:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1184:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *----------------------------------------------------------*/
1185:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1186:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1187:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1188:firmware/FreeRTOSV6.1.0/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1189:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1190:firmware/FreeRTOSV6.1.0/Source/tasks.c **** portTickType xTicks;
1191:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1192:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1193:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portENTER_CRITICAL();
1194:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1195:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xTicks = xTickCount;
1196:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1197:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portEXIT_CRITICAL();
1198:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1199:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	return xTicks;
1200:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1201:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1202:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1203:firmware/FreeRTOSV6.1.0/Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1204:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1205:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	return xTickCount;
1206:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1207:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1208:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1209:firmware/FreeRTOSV6.1.0/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1210:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1211:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1212:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portBASE_TYPE. */
1213:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
1214:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1215:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1216:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1217:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1218:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1219:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1220:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1221:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1222:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1223:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1224:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1225:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1226:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vTaskSuspendAll();
1227:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1228:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1229:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1230:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1231:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1232:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1233:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1234:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
1235:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1236:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			do
1237:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1238:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				uxQueue--;
1239:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1240:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1241:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
1242:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1243:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
1244:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1245:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1246:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1247:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1248:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1249:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1250:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1251:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1252:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1253:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1254:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1255:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1256:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1257:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1258:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1259:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
1260:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, tskDELETED_
1261:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
1262:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1263:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#endif
1264:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1265:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1266:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1267:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1268:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
1269:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
1270:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
1271:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1272:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#endif
1273:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1274:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xTaskResumeAll();
1275:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1276:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1277:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
1278:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*----------------------------------------------------------*/
1279:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1280:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1281:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1282:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1283:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1284:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1285:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned long ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1286:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1287:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1288:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1289:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1290:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vTaskSuspendAll();
1291:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1292:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1293:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1294:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			buffer. */
1295:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1296:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1297:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1298:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1299:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
1300:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1301:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			do
1302:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1303:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				uxQueue--;
1304:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1305:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1306:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
1307:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1308:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
1309:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1310:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1311:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1312:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1313:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1314:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1315:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1316:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1317:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1318:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1319:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1320:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1321:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1322:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1323:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1324:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
1325:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, u
1326:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
1327:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1328:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#endif
1329:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1330:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1331:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1332:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1333:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
1334:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, ulTotal
1335:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
1336:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1337:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#endif
1338:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1339:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xTaskResumeAll();
1340:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1341:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1342:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
1343:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*----------------------------------------------------------*/
1344:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1345:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1346:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1347:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1348:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1349:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
1350:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1351:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
1352:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
1353:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
1354:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTracing = pdTRUE;
1355:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1356:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
1357:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1358:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1359:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
1360:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*----------------------------------------------------------*/
1361:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1362:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1363:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1364:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned long ulTaskEndTrace( void )
1365:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1366:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned long ulBufferLength;
1367:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1368:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
1369:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTracing = pdFALSE;
1370:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
1371:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1372:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
1373:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1374:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		return ulBufferLength;
1375:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1376:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1377:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
1378:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1379:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1380:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1381:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------
1382:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1383:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * documented in task.h
1384:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *----------------------------------------------------------*/
1385:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1386:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1387:firmware/FreeRTOSV6.1.0/Source/tasks.c **** void vTaskIncrementTick( void )
1388:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1389:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1390:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1391:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tasks to be unblocked. */
1392:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1393:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1394:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		++xTickCount;
1395:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0 )
1396:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1397:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xList *pxTemp;
1398:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1399:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1400:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1401:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			an error! */
1402:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
1403:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
1404:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
1405:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xNumOfOverflows++;
1406:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1407:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1408:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1409:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		prvCheckDelayedTasks();
1410:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1411:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	else
1412:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1413:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		++uxMissedTicks;
1414:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1415:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1416:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		scheduler is locked. */
1417:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1418:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1419:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			extern void vApplicationTickHook( void );
1420:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1421:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vApplicationTickHook();
1422:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1423:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#endif
1424:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1425:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1426:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1427:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1428:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		extern void vApplicationTickHook( void );
1429:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1430:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1431:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1432:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( uxMissedTicks == 0 )
1433:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1434:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vApplicationTickHook();
1435:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1436:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1437:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
1438:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1439:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1440:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1441:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1442:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1443:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( ( INCLUDE_vTaskCleanUpResources == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1444:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1445:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	void vTaskCleanUpResources( void )
1446:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1447:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned short usQueue;
1448:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	volatile tskTCB *pxTCB;
1449:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1450:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		usQueue = ( unsigned short ) uxTopUsedPriority + ( unsigned short ) 1;
1451:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1452:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Remove any TCB's from the ready queues. */
1453:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		do
1454:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1455:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			usQueue--;
1456:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1457:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			while( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ usQueue ] ) ) )
1458:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1459:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &( pxReadyTasksLists[ usQueue ] ) );
1460:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1461:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1462:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				prvDeleteTCB( ( tskTCB * ) pxTCB );
1463:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1464:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}while( usQueue > ( unsigned short ) tskIDLE_PRIORITY );
1465:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1466:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Remove any TCB's from the delayed queue. */
1467:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList1 ) )
1468:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1469:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList1 );
1470:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1471:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1472:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1473:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1474:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1475:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Remove any TCB's from the overflow delayed queue. */
1476:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList2 ) )
1477:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1478:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList2 );
1479:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1480:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1481:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1482:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1483:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1484:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		while( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1485:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1486:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xSuspendedTaskList );
1487:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1488:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1489:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1490:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1491:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1492:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1493:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
1494:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1495:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1496:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1497:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1498:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxTagValue )
1499:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1500:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tskTCB *xTCB;
1501:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1502:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1503:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTask == NULL )
1504:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1505:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1506:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1507:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		else
1508:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1509:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1510:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1511:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1512:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1513:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1514:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
1515:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTCB->pxTaskTag = pxTagValue;
1516:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
1517:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1518:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1519:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
1520:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1521:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1522:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1523:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1524:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1525:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1526:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tskTCB *xTCB;
1527:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1528:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1529:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1530:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTask == NULL )
1531:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1532:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1533:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1534:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		else
1535:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1536:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1537:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1538:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1539:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1540:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1541:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
1542:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1543:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
1544:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1545:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		return xReturn;
1546:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1547:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1548:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
1549:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1550:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1551:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1552:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1553:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1554:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1555:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tskTCB *xTCB;
1556:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portBASE_TYPE xReturn;
1557:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1558:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1559:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTask == NULL )
1560:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1561:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1562:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1563:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		else
1564:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1565:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1566:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1567:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1568:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1569:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1570:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1571:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1572:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		else
1573:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1574:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xReturn = pdFAIL;
1575:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1576:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1577:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		return xReturn;
1578:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1579:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1580:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
1581:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1582:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1583:firmware/FreeRTOSV6.1.0/Source/tasks.c **** void vTaskSwitchContext( void )
1584:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1585:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
1586:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1587:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1588:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		switch. */
1589:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xMissedYield = pdTRUE;
1590:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		return;
1591:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1592:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1593:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	traceTASK_SWITCHED_OUT();
1594:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1595:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1596:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1597:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		unsigned long ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1598:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1599:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Add the amount of time the task has been running to the accumulated
1600:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			time so far.  The time the task started running was stored in
1601:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			ulTaskSwitchedInTime.  Note that there is no overflow protection here
1602:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			so count values are only valid until the timer overflows.  Generally
1603:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			this will be about 1 hour assuming a 1uS timer increment. */
1604:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1605:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			ulTaskSwitchedInTime = ulTempCounter;
1606:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1607:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
1608:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1609:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1610:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1611:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1612:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Find the highest priority queue that contains ready tasks. */
1613:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
1614:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1615:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		--uxTopReadyPriority;
1616:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1617:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1618:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1619:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	same priority get an equal share of the processor time. */
1620:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
1621:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1622:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	traceTASK_SWITCHED_IN();
1623:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vWriteTraceToBuffer();
1624:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1625:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1626:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1627:firmware/FreeRTOSV6.1.0/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1628:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1629:firmware/FreeRTOSV6.1.0/Source/tasks.c **** portTickType xTimeToWake;
1630:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1631:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1632:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1633:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1634:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1635:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1636:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	is the first to be woken by the event. */
1637:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1638:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1639:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1640:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1641:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1642:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1643:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1644:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1645:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1646:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1647:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
1648:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1649:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1650:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1651:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			indefinitely. */
1652:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
1653:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1654:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		else
1655:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1656:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1657:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1658:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1659:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1660:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1661:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1662:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
1663:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1664:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1665:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1666:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1667:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			else
1668:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1669:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* The wake time has not overflowed, so we can use the current block list. */
1670:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1671:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1672:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1673:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1674:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#else
1675:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1676:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1677:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1678:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1679:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1680:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1681:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1682:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
1683:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1684:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1685:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1686:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1687:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			else
1688:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1689:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* The wake time has not overflowed, so we can use the current block list. */
1690:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1691:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1692:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1693:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
1694:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1695:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1696:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1697:firmware/FreeRTOSV6.1.0/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1698:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1699:firmware/FreeRTOSV6.1.0/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1700:firmware/FreeRTOSV6.1.0/Source/tasks.c **** portBASE_TYPE xReturn;
1701:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1702:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1703:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1704:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1705:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1706:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1707:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	it to the ready list.
1708:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1709:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1710:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1711:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	means we can always expect exclusive access to the event list here. */
1712:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1713:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
1714:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1715:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1716:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1717:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
1718:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
1719:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1720:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	else
1721:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1722:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1723:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1724:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1725:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1726:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1727:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
1728:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1729:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1730:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1731:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		the calling task to know if it should force a context
1732:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		switch now. */
1733:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xReturn = pdTRUE;
1734:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1735:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	else
1736:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1737:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xReturn = pdFALSE;
1738:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1739:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1740:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	return xReturn;
1741:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1742:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1743:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1744:firmware/FreeRTOSV6.1.0/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1745:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1746:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
1747:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
1748:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1749:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1750:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1751:firmware/FreeRTOSV6.1.0/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1752:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1753:firmware/FreeRTOSV6.1.0/Source/tasks.c **** portBASE_TYPE xReturn;
1754:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1755:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portENTER_CRITICAL();
1756:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1757:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1758:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1759:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1760:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			therefore never time out. */
1761:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
1762:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1763:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				xReturn = pdFALSE;
1764:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1765:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1766:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#endif
1767:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1768:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
1769:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1770:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1771:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1772:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1773:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1774:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xReturn = pdTRUE;
1775:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1776:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
1777:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1778:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1779:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
1780:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
1781:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xReturn = pdFALSE;
1782:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1783:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		else
1784:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1785:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xReturn = pdTRUE;
1786:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1787:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1788:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portEXIT_CRITICAL();
1789:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1790:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	return xReturn;
1791:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1792:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1793:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1794:firmware/FreeRTOSV6.1.0/Source/tasks.c **** void vTaskMissedYield( void )
1795:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1796:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	xMissedYield = pdTRUE;
1797:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1798:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1799:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*
1800:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * -----------------------------------------------------------
1801:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * The Idle task.
1802:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * ----------------------------------------------------------
1803:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *
1804:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1805:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1806:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *
1807:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1808:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *
1809:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  */
1810:firmware/FreeRTOSV6.1.0/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1811:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1812:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Stop warnings. */
1813:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	( void ) pvParameters;
1814:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1815:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	for( ;; )
1816:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1817:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* See if any tasks have been deleted. */
1818:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
1819:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1820:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1821:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1822:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1823:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			see if any other task has become available.  If we are using
1824:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1825:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			will automatically get the processor anyway. */
1826:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			taskYIELD();
1827:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1828:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#endif
1829:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1830:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1831:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1832:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1833:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1834:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			to run then the idle task should yield before the end of the
1835:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			timeslice.
1836:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1837:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			A critical region is not required here as we are just reading from
1838:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1839:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1840:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1841:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1842:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
1843:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				taskYIELD();
1844:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
1845:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1846:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#endif
1847:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1848:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1849:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1850:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1851:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1852:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1853:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			allows the application designer to add background functionality
1854:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			without the overhead of a separate task.
1855:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1856:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1857:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vApplicationIdleHook();
1858:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1859:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#endif
1860:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1861:firmware/FreeRTOSV6.1.0/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1862:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1863:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1864:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1865:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1866:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1867:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1868:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1869:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------
1870:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  * File private functions documented at the top of the file.
1871:firmware/FreeRTOSV6.1.0/Source/tasks.c ****  *----------------------------------------------------------*/
1872:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1873:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1874:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1875:firmware/FreeRTOSV6.1.0/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1876:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1877:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Store the function name in the TCB. */
1878:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1879:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1880:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1881:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
1882:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1883:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
1884:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
1885:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1886:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1887:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	remove the privilege bit if one is present. */
1888:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
1889:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1890:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - 1;
1891:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1892:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1893:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
1894:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1895:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1896:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
1897:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1898:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
1899:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1900:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
1901:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
1902:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1903:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1904:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1905:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
1906:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1907:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Event lists are always in priority order. */
1908:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
1909:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
1910:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1911:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1912:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1913:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0;
1914:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1915:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
1916:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1917:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1918:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1919:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1920:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1921:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
1922:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1923:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1924:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1925:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
1926:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1927:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
1928:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1929:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1930:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1931:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1932:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1933:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#else
1934:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1935:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		( void ) xRegions;
1936:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		( void ) usStackDepth;
1937:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1938:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
1939:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1940:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1941:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1942:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
1943:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1944:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
1945:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1946:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tskTCB *pxTCB;
1947:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	
1948:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
1949:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
1950:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTaskToModify = NULL;
1951:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
1952:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1953:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
1954:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
1955:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1956:firmware/FreeRTOSV6.1.0/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
1957:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1958:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/*-----------------------------------------------------------*/
1959:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
1960:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1961:firmware/FreeRTOSV6.1.0/Source/tasks.c **** static void prvInitialiseTaskLists( void )
1962:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1963:firmware/FreeRTOSV6.1.0/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
1964:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1965:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
1966:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1967:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
1968:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1969:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1970:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
1971:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
1972:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
1973:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1974:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
1975:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1976:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
1977:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1978:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
1979:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1980:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1981:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1982:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
1983:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
1984:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
1985:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1986:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
1987:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	using list2. */
1988:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
1989:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
1990:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
1991:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
1992:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1993:firmware/FreeRTOSV6.1.0/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
1994:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
1995:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
1996:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
1997:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
1998:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
1999:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2000:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		too often in the idle task. */
2001:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
2002:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
2003:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vTaskSuspendAll();
2004:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2005:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTaskResumeAll();
2006:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2007:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( !xListIsEmpty )
2008:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
2009:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				tskTCB *pxTCB;
2010:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2011:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				portENTER_CRITICAL();
2012:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
2013:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
2014:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
2015:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
2016:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					--uxTasksDeleted;
2017:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
2018:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				portEXIT_CRITICAL();
2019:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2020:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
2021:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
2022:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
2023:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
2024:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	#endif
2025:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
2026:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
2027:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2028:firmware/FreeRTOSV6.1.0/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2029:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
2030:firmware/FreeRTOSV6.1.0/Source/tasks.c **** tskTCB *pxNewTCB;
2031:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2032:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2033:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	the implementation of the port malloc function. */
2034:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
2035:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2036:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( pxNewTCB != NULL )
2037:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
2038:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2039:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2040:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		be deleted later if required. */
2041:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
2042:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2043:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
2044:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
2045:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2046:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vPortFree( pxNewTCB );
2047:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxNewTCB = NULL;
2048:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
2049:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		else
2050:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
2051:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Just to help debugging. */
2052:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
2053:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
2054:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
2055:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2056:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	return pxNewTCB;
2057:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
2058:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
2059:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2060:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2061:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2062:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2063:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
  31              		.loc 1 2063 0
  32              		.cfi_startproc
  33              		@ args = 0, pretend = 0, frame = 0
  34              		@ frame_needed = 0, uses_anonymous_args = 0
  35              	.LVL0:
  36 0000 2DE9FF41 		push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
  37              	.LCFI0:
  38              		.cfi_def_cfa_offset 40
  39              	.LBB6:
2064:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2065:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned short usStackRemaining;
2066:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2067:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2068:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
  40              		.loc 1 2068 0
  41 0004 4B68     		ldr	r3, [r1, #4]
  42              		.cfi_offset 14, -4
  43              		.cfi_offset 8, -8
  44              		.cfi_offset 7, -12
  45              		.cfi_offset 6, -16
  46              		.cfi_offset 5, -20
  47              		.cfi_offset 4, -24
  48              		.cfi_offset 3, -28
  49              		.cfi_offset 2, -32
  50              		.cfi_offset 1, -36
  51              		.cfi_offset 0, -40
  52              	.LBE6:
2063:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
  53              		.loc 1 2063 0
  54 0006 1746     		mov	r7, r2
  55              	.LBB7:
  56              		.loc 1 2068 0
  57 0008 5B68     		ldr	r3, [r3, #4]
  58 000a 01F10802 		add	r2, r1, #8
  59              	.LVL1:
  60 000e 4B60     		str	r3, [r1, #4]
  61 0010 9342     		cmp	r3, r2
  62 0012 08BF     		it	eq
  63 0014 5B68     		ldreq	r3, [r3, #4]
  64              	.LBE7:
2063:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
  65              		.loc 1 2063 0
  66 0016 0646     		mov	r6, r0
  67              	.LBB8:
  68              		.loc 1 2068 0
  69 0018 08BF     		it	eq
  70 001a 4B60     		streq	r3, [r1, #4]
  71 001c 4B68     		ldr	r3, [r1, #4]
  72              	.LBE8:
2063:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
  73              		.loc 1 2063 0
  74 001e 0C46     		mov	r4, r1
  75              	.LVL2:
  76              	.LBB9:
  77              		.loc 1 2068 0
  78 0020 D3F80C80 		ldr	r8, [r3, #12]
  79              	.LVL3:
  80              	.L5:
  81              	.LBE9:
  82              	.LBB10:
2069:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		do
2070:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
2071:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
  83              		.loc 1 2071 0
  84 0024 6368     		ldr	r3, [r4, #4]
  85 0026 04F10802 		add	r2, r4, #8
  86 002a 5B68     		ldr	r3, [r3, #4]
  87 002c 6360     		str	r3, [r4, #4]
  88 002e 9342     		cmp	r3, r2
  89 0030 04BF     		itt	eq
  90 0032 5B68     		ldreq	r3, [r3, #4]
  91 0034 6360     		streq	r3, [r4, #4]
  92 0036 6368     		ldr	r3, [r4, #4]
  93 0038 DD68     		ldr	r5, [r3, #12]
  94              	.LVL4:
  95              	.LBE10:
2072:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2073:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
2074:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2075:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
2076:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#else
2077:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
2078:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
  96              		.loc 1 2078 0
  97 003a 0023     		movs	r3, #0
  98 003c 296B     		ldr	r1, [r5, #48]
  99              	.LVL5:
 100              	.L4:
 101              	.LBB11:
 102              	.LBB12:
2079:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
2080:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			#endif			
2081:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			
2082:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2083:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2084:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2085:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2086:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
2087:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2088:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
2089:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
2090:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2091:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2092:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2093:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2094:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
2095:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2096:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2097:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2098:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2099:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2100:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		do
2101:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
2102:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Get next TCB in from the list. */
2103:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2104:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2105:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			/* Divide by zero check. */
2106:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
2107:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			{
2108:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				/* Has the task run at all? */
2109:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0 )
2110:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
2111:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2112:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2113:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
2114:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				else
2115:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				{
2116:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					/* What percentage of the total run time as the task used?
2117:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					This will always be rounded down to the nearest integer. */
2118:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					ulStatsAsPercentage = ( 100UL * pxNextTCB->ulRunTimeCounter ) / ulTotalRunTime;
2119:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2120:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2121:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					{
2122:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2123:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					}
2124:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					else
2125:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					{
2126:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2127:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2128:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2129:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					}
2130:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				}
2131:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2132:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2133:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}
2134:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2135:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2136:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
2137:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2138:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
2139:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
2140:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2141:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2142:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2143:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2144:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
2145:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	register unsigned short usCount = 0;
2146:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2147:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 103              		.loc 1 2147 0
 104 003e C85C     		ldrb	r0, [r1, r3]	@ zero_extendqisi2
 105              	.LBE12:
 106              	.LBE11:
2078:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
 107              		.loc 1 2078 0
 108 0040 9AB2     		uxth	r2, r3
 109              	.LVL6:
 110              	.LBB14:
 111              	.LBB13:
 112              		.loc 1 2147 0
 113 0042 0133     		adds	r3, r3, #1
 114 0044 A528     		cmp	r0, #165
 115 0046 FAD0     		beq	.L4
 116              	.LVL7:
 117              	.LBE13:
 118              	.LBE14:
2082:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 119              		.loc 1 2082 0
 120 0048 E96A     		ldr	r1, [r5, #44]
 121 004a 6B6C     		ldr	r3, [r5, #68]
 122 004c 9208     		lsrs	r2, r2, #2
 123              	.LVL8:
 124 004e 0091     		str	r1, [sp, #0]
 125 0050 0192     		str	r2, [sp, #4]
 126 0052 0293     		str	r3, [sp, #8]
 127 0054 0749     		ldr	r1, .L6
 128 0056 05F13402 		add	r2, r5, #52
 129 005a 3B46     		mov	r3, r7
 130 005c 0648     		ldr	r0, .L6+4
 131 005e FFF7FEFF 		bl	sprintf
2083:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
 132              		.loc 1 2083 0
 133 0062 3046     		mov	r0, r6
 134 0064 0449     		ldr	r1, .L6+4
 135 0066 FFF7FEFF 		bl	strcat
2085:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 136              		.loc 1 2085 0
 137 006a 4545     		cmp	r5, r8
 138 006c DAD1     		bne	.L5
2086:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 139              		.loc 1 2086 0
 140 006e BDE8FF81 		pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, pc}
 141              	.L7:
 142 0072 00BF     		.align	2
 143              	.L6:
 144 0074 00000000 		.word	.LC0
 145 0078 00000000 		.word	.LANCHOR0
 146              		.cfi_endproc
 147              	.LFE32:
 149              		.section	.text.xTaskGenericCreate,"ax",%progbits
 150              		.align	1
 151              		.global	xTaskGenericCreate
 152              		.thumb
 153              		.thumb_func
 155              	xTaskGenericCreate:
 156              	.LFB0:
 387:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 157              		.loc 1 387 0
 158              		.cfi_startproc
 159              		@ args = 16, pretend = 0, frame = 0
 160              		@ frame_needed = 0, uses_anonymous_args = 0
 161              	.LVL9:
 162 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 163              	.LCFI1:
 164              		.cfi_def_cfa_offset 40
 387:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 165              		.loc 1 387 0
 166 0004 8246     		mov	sl, r0
 167              		.cfi_offset 14, -4
 168              		.cfi_offset 11, -8
 169              		.cfi_offset 10, -12
 170              		.cfi_offset 9, -16
 171              		.cfi_offset 8, -20
 172              		.cfi_offset 7, -24
 173              		.cfi_offset 6, -28
 174              		.cfi_offset 5, -32
 175              		.cfi_offset 4, -36
 176              		.cfi_offset 3, -40
 177              	.LBB22:
 178              	.LBB24:
2034:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 179              		.loc 1 2034 0
 180 0006 4820     		movs	r0, #72
 181              	.LVL10:
 182              	.LBE24:
 183              	.LBE22:
 387:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 184              		.loc 1 387 0
 185 0008 0D46     		mov	r5, r1
 186 000a 1446     		mov	r4, r2
 187              	.LVL11:
 188 000c 9946     		mov	r9, r3
 189 000e 0A9F     		ldr	r7, [sp, #40]
 190 0010 DDF82C80 		ldr	r8, [sp, #44]
 191 0014 DDF830B0 		ldr	fp, [sp, #48]
 192              	.LVL12:
 193              	.LBB26:
 194              	.LBB23:
2034:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 195              		.loc 1 2034 0
 196 0018 FFF7FEFF 		bl	pvPortMalloc
 197              	.LVL13:
2036:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( pxNewTCB != NULL )
 198              		.loc 1 2036 0
 199 001c 0646     		mov	r6, r0
 200 001e 0028     		cmp	r0, #0
 201 0020 00F0A180 		beq	.L18
2041:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 202              		.loc 1 2041 0
 203 0024 BBF1000F 		cmp	fp, #0
 204 0028 03D1     		bne	.L10
 205 002a A000     		lsls	r0, r4, #2
 206              	.LVL14:
 207 002c FFF7FEFF 		bl	pvPortMalloc
 208 0030 8346     		mov	fp, r0
 209              	.L10:
 210 0032 C6F830B0 		str	fp, [r6, #48]
2043:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 211              		.loc 1 2043 0
 212 0036 BBF1000F 		cmp	fp, #0
 213 003a 03D1     		bne	.L11
2046:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vPortFree( pxNewTCB );
 214              		.loc 1 2046 0
 215 003c 3046     		mov	r0, r6
 216 003e FFF7FEFF 		bl	vPortFree
 217              	.LVL15:
 218 0042 90E0     		b	.L18
 219              	.LVL16:
 220              	.L11:
2052:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 221              		.loc 1 2052 0
 222 0044 A200     		lsls	r2, r4, #2
 223 0046 5846     		mov	r0, fp
 224 0048 A521     		movs	r1, #165
 225 004a FFF7FEFF 		bl	memset
 226              	.LVL17:
 227              	.LBE23:
 228              	.LBE26:
 229              	.LBB27:
 419:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 230              		.loc 1 419 0
 231 004e 336B     		ldr	r3, [r6, #48]
 232              	.LBB28:
 233              	.LBB30:
1881:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 234              		.loc 1 1881 0
 235 0050 2946     		mov	r1, r5
 236 0052 1022     		movs	r2, #16
 237              	.LBE30:
 238              	.LBE28:
 419:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 239              		.loc 1 419 0
 240 0054 013C     		subs	r4, r4, #1
 241              	.LVL18:
 242              	.LBB33:
 243              	.LBB31:
1881:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 244              		.loc 1 1881 0
 245 0056 06F13400 		add	r0, r6, #52
 246              	.LBE31:
 247              	.LBE33:
 419:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 248              		.loc 1 419 0
 249 005a 03EB8404 		add	r4, r3, r4, lsl #2
 250              	.LVL19:
 251              	.LBB34:
 252              	.LBB29:
1884:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 253              		.loc 1 1884 0
 254 005e 042F     		cmp	r7, #4
 255 0060 34BF     		ite	cc
 256 0062 BB46     		movcc	fp, r7
 257 0064 4FF0040B 		movcs	fp, #4
1881:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 258              		.loc 1 1881 0
 259 0068 FFF7FEFF 		bl	strncpy
1900:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 260              		.loc 1 1900 0
 261 006c 351D     		adds	r5, r6, #4
 262              	.LVL20:
1884:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 263              		.loc 1 1884 0
 264 006e 0023     		movs	r3, #0
 265 0070 86F84330 		strb	r3, [r6, #67]
1900:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 266              		.loc 1 1900 0
 267 0074 2846     		mov	r0, r5
1893:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 268              		.loc 1 1893 0
 269 0076 C6F82CB0 		str	fp, [r6, #44]
1900:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 270              		.loc 1 1900 0
 271 007a FFF7FEFF 		bl	vListInitialiseItem
1901:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 272              		.loc 1 1901 0
 273 007e 06F11800 		add	r0, r6, #24
 274 0082 FFF7FEFF 		bl	vListInitialiseItem
 275              	.LBE29:
 276              	.LBE34:
 420:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~
 277              		.loc 1 420 0
 278 0086 24F00704 		bic	r4, r4, #7
 279              	.LVL21:
 280              	.LBB35:
 281              	.LBB32:
1908:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 282              		.loc 1 1908 0
 283 008a CBF10503 		rsb	r3, fp, #5
1905:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 284              		.loc 1 1905 0
 285 008e 3661     		str	r6, [r6, #16]
1908:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 286              		.loc 1 1908 0
 287 0090 B361     		str	r3, [r6, #24]
1909:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 288              		.loc 1 1909 0
 289 0092 7662     		str	r6, [r6, #36]
 290              	.LBE32:
 291              	.LBE35:
 446:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 292              		.loc 1 446 0
 293 0094 2046     		mov	r0, r4
 294 0096 5146     		mov	r1, sl
 295 0098 4A46     		mov	r2, r9
 296 009a FFF7FEFF 		bl	pxPortInitialiseStack
 297 009e 3060     		str	r0, [r6, #0]
 450:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 298              		.loc 1 450 0
 299 00a0 B8F1000F 		cmp	r8, #0
 300 00a4 01D0     		beq	.L12
 455:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 301              		.loc 1 455 0
 302 00a6 C8F80060 		str	r6, [r8, #0]
 303              	.L12:
 460:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
 304              		.loc 1 460 0
 305 00aa FFF7FEFF 		bl	vPortEnterCritical
 462:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 306              		.loc 1 462 0
 307 00ae 334B     		ldr	r3, .L21
 463:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 308              		.loc 1 463 0
 309 00b0 334C     		ldr	r4, .L21+4
 310              	.LVL22:
 462:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 311              		.loc 1 462 0
 312 00b2 1A68     		ldr	r2, [r3, #0]
 313 00b4 DFF8F090 		ldr	r9, .L21+44
 314              	.LVL23:
 315 00b8 0132     		adds	r2, r2, #1
 316 00ba 1A60     		str	r2, [r3, #0]
 463:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 317              		.loc 1 463 0
 318 00bc 2268     		ldr	r2, [r4, #0]
 319 00be 42BB     		cbnz	r2, .L13
 467:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 320              		.loc 1 467 0
 321 00c0 2660     		str	r6, [r4, #0]
 469:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 322              		.loc 1 469 0
 323 00c2 1B68     		ldr	r3, [r3, #0]
 324 00c4 012B     		cmp	r3, #1
 325 00c6 2CD1     		bne	.L14
 326 00c8 9046     		mov	r8, r2
 327              	.L15:
 328              	.LBB36:
 329              	.LBB37:
1967:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 330              		.loc 1 1967 0
 331 00ca 1420     		movs	r0, #20
 332 00cc 00FB0890 		mla	r0, r0, r8, r9
1965:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 333              		.loc 1 1965 0
 334 00d0 08F10108 		add	r8, r8, #1
1967:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 335              		.loc 1 1967 0
 336 00d4 FFF7FEFF 		bl	vListInitialise
 337              	.LVL24:
1965:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 338              		.loc 1 1965 0
 339 00d8 B8F1050F 		cmp	r8, #5
 340 00dc F5D1     		bne	.L15
1970:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 341              		.loc 1 1970 0
 342 00de DFF8CCA0 		ldr	sl, .L21+48
 343              	.LVL25:
1971:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 344              		.loc 1 1971 0
 345 00e2 DFF8CC80 		ldr	r8, .L21+52
 346              	.LVL26:
1970:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 347              		.loc 1 1970 0
 348 00e6 5046     		mov	r0, sl
 349 00e8 FFF7FEFF 		bl	vListInitialise
1971:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 350              		.loc 1 1971 0
 351 00ec 4046     		mov	r0, r8
 352 00ee FFF7FEFF 		bl	vListInitialise
1972:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 353              		.loc 1 1972 0
 354 00f2 2448     		ldr	r0, .L21+8
 355 00f4 FFF7FEFF 		bl	vListInitialise
1976:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 356              		.loc 1 1976 0
 357 00f8 2348     		ldr	r0, .L21+12
 358 00fa FFF7FEFF 		bl	vListInitialise
1982:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 359              		.loc 1 1982 0
 360 00fe 2348     		ldr	r0, .L21+16
 361 0100 FFF7FEFF 		bl	vListInitialise
1988:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 362              		.loc 1 1988 0
 363 0104 224B     		ldr	r3, .L21+20
 364 0106 C3F800A0 		str	sl, [r3, #0]
1989:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 365              		.loc 1 1989 0
 366 010a 224B     		ldr	r3, .L21+24
 367 010c C3F80080 		str	r8, [r3, #0]
 368 0110 07E0     		b	.L14
 369              	.LVL27:
 370              	.L13:
 371              	.LBE37:
 372              	.LBE36:
 482:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 373              		.loc 1 482 0
 374 0112 214B     		ldr	r3, .L21+28
 375 0114 1B68     		ldr	r3, [r3, #0]
 376 0116 23B9     		cbnz	r3, .L14
 484:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 377              		.loc 1 484 0
 378 0118 2368     		ldr	r3, [r4, #0]
 379 011a DB6A     		ldr	r3, [r3, #44]
 380 011c BB42     		cmp	r3, r7
 486:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 381              		.loc 1 486 0
 382 011e 98BF     		it	ls
 383 0120 2660     		strls	r6, [r4, #0]
 384              	.LVL28:
 385              	.L14:
 493:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 386              		.loc 1 493 0
 387 0122 1E4A     		ldr	r2, .L21+32
 388 0124 F36A     		ldr	r3, [r6, #44]
 389 0126 1168     		ldr	r1, [r2, #0]
 390 0128 8B42     		cmp	r3, r1
 495:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 391              		.loc 1 495 0
 392 012a 88BF     		it	hi
 393 012c 1360     		strhi	r3, [r2, #0]
 501:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 394              		.loc 1 501 0
 395 012e 1C4A     		ldr	r2, .L21+36
 396 0130 1168     		ldr	r1, [r2, #0]
 397 0132 7164     		str	r1, [r6, #68]
 504:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxTaskNumber++;
 398              		.loc 1 504 0
 399 0134 0131     		adds	r1, r1, #1
 400 0136 1160     		str	r1, [r2, #0]
 506:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 401              		.loc 1 506 0
 402 0138 1A4A     		ldr	r2, .L21+40
 403 013a 1168     		ldr	r1, [r2, #0]
 404 013c 8B42     		cmp	r3, r1
 405 013e 88BF     		it	hi
 406 0140 1360     		strhi	r3, [r2, #0]
 407 0142 1420     		movs	r0, #20
 408 0144 00FB0390 		mla	r0, r0, r3, r9
 409 0148 2946     		mov	r1, r5
 410 014a FFF7FEFF 		bl	vListInsertEnd
 411              	.LVL29:
 511:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
 412              		.loc 1 511 0
 413 014e FFF7FEFF 		bl	vPortExitCritical
 414              	.LBE27:
 521:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 415              		.loc 1 521 0
 416 0152 114B     		ldr	r3, .L21+28
 417 0154 1B68     		ldr	r3, [r3, #0]
 418 0156 53B1     		cbz	r3, .L19
 525:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 419              		.loc 1 525 0
 420 0158 2368     		ldr	r3, [r4, #0]
 421 015a DB6A     		ldr	r3, [r3, #44]
 422 015c BB42     		cmp	r3, r7
 423 015e 09D2     		bcs	.L20
 527:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				portYIELD_WITHIN_API();
 424              		.loc 1 527 0
 425 0160 FFF7FEFF 		bl	vPortYieldFromISR
 426 0164 03E0     		b	.L19
 427              	.LVL30:
 428              	.L18:
 429              	.LBB38:
 430              	.LBB25:
 515:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 431              		.loc 1 515 0
 432 0166 4FF0FF30 		mov	r0, #-1
 433 016a BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 434              	.LVL31:
 435              	.L19:
 436              	.LBE25:
 437              	.LBE38:
 508:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xReturn = pdPASS;
 438              		.loc 1 508 0
 439 016e 0120     		movs	r0, #1
 440 0170 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 441              	.L20:
 442 0174 0120     		movs	r0, #1
 533:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 443              		.loc 1 533 0
 444 0176 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 445              	.L22:
 446 017a 00BF     		.align	2
 447              	.L21:
 448 017c 00000000 		.word	.LANCHOR1
 449 0180 00000000 		.word	.LANCHOR2
 450 0184 00000000 		.word	.LANCHOR6
 451 0188 00000000 		.word	.LANCHOR7
 452 018c 00000000 		.word	.LANCHOR8
 453 0190 00000000 		.word	.LANCHOR9
 454 0194 00000000 		.word	.LANCHOR10
 455 0198 00000000 		.word	.LANCHOR11
 456 019c 00000000 		.word	.LANCHOR12
 457 01a0 00000000 		.word	.LANCHOR13
 458 01a4 00000000 		.word	.LANCHOR14
 459 01a8 00000000 		.word	.LANCHOR3
 460 01ac 00000000 		.word	.LANCHOR4
 461 01b0 00000000 		.word	.LANCHOR5
 462              		.cfi_endproc
 463              	.LFE0:
 465              		.section	.text.vTaskDelete,"ax",%progbits
 466              		.align	1
 467              		.global	vTaskDelete
 468              		.thumb
 469              		.thumb_func
 471              	vTaskDelete:
 472              	.LFB1:
 539:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 473              		.loc 1 539 0
 474              		.cfi_startproc
 475              		@ args = 0, pretend = 0, frame = 0
 476              		@ frame_needed = 0, uses_anonymous_args = 0
 477              	.LVL32:
 478 0000 70B5     		push	{r4, r5, r6, lr}
 479              	.LCFI2:
 480              		.cfi_def_cfa_offset 16
 539:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 481              		.loc 1 539 0
 482 0002 0446     		mov	r4, r0
 483              		.cfi_offset 14, -4
 484              		.cfi_offset 6, -8
 485              		.cfi_offset 5, -12
 486              		.cfi_offset 4, -16
 542:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
 487              		.loc 1 542 0
 488 0004 FFF7FEFF 		bl	vPortEnterCritical
 489              	.LVL33:
 546:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 490              		.loc 1 546 0
 491 0008 144B     		ldr	r3, .L29
 492 000a 1A68     		ldr	r2, [r3, #0]
 493 000c 9442     		cmp	r4, r2
 494 000e 00D0     		beq	.L24
 552:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 495              		.loc 1 552 0
 496 0010 14B9     		cbnz	r4, .L25
 497              	.L24:
 552:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 498              		.loc 1 552 0 is_stmt 0 discriminator 1
 499 0012 1D68     		ldr	r5, [r3, #0]
 500 0014 0024     		movs	r4, #0
 501              	.LVL34:
 502 0016 00E0     		b	.L26
 503              	.LVL35:
 504              	.L25:
 552:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 505              		.loc 1 552 0 discriminator 2
 506 0018 2546     		mov	r5, r4
 507              	.LVL36:
 508              	.L26:
 558:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 509              		.loc 1 558 0 is_stmt 1 discriminator 3
 510 001a 2E1D     		adds	r6, r5, #4
 511 001c 3046     		mov	r0, r6
 512 001e FFF7FEFF 		bl	vListRemove
 561:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 513              		.loc 1 561 0 discriminator 3
 514 0022 AB6A     		ldr	r3, [r5, #40]
 515 0024 1BB1     		cbz	r3, .L27
 563:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 516              		.loc 1 563 0
 517 0026 05F11800 		add	r0, r5, #24
 518 002a FFF7FEFF 		bl	vListRemove
 519              	.L27:
 566:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 520              		.loc 1 566 0
 521 002e 0C48     		ldr	r0, .L29+4
 522 0030 3146     		mov	r1, r6
 523 0032 FFF7FEFF 		bl	vListInsertEnd
 571:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			++uxTasksDeleted;
 524              		.loc 1 571 0
 525 0036 0B4B     		ldr	r3, .L29+8
 526 0038 1A68     		ldr	r2, [r3, #0]
 527 003a 0132     		adds	r2, r2, #1
 528 003c 1A60     		str	r2, [r3, #0]
 575:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxTaskNumber++;
 529              		.loc 1 575 0
 530 003e 0A4B     		ldr	r3, .L29+12
 531 0040 1A68     		ldr	r2, [r3, #0]
 532 0042 0132     		adds	r2, r2, #1
 533 0044 1A60     		str	r2, [r3, #0]
 579:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
 534              		.loc 1 579 0
 535 0046 FFF7FEFF 		bl	vPortExitCritical
 582:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 536              		.loc 1 582 0
 537 004a 084B     		ldr	r3, .L29+16
 538 004c 1B68     		ldr	r3, [r3, #0]
 539 004e 23B1     		cbz	r3, .L23
 584:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 540              		.loc 1 584 0
 541 0050 1CB9     		cbnz	r4, .L23
 589:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 542              		.loc 1 589 0
 543 0052 BDE87040 		pop	{r4, r5, r6, lr}
 586:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				portYIELD_WITHIN_API();
 544              		.loc 1 586 0
 545 0056 FFF7FEBF 		b	vPortYieldFromISR
 546              	.L23:
 547 005a 70BD     		pop	{r4, r5, r6, pc}
 548              	.L30:
 549              		.align	2
 550              	.L29:
 551 005c 00000000 		.word	.LANCHOR2
 552 0060 00000000 		.word	.LANCHOR7
 553 0064 00000000 		.word	.LANCHOR15
 554 0068 00000000 		.word	.LANCHOR13
 555 006c 00000000 		.word	.LANCHOR11
 556              		.cfi_endproc
 557              	.LFE1:
 559              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 560              		.align	1
 561              		.global	uxTaskPriorityGet
 562              		.thumb
 563              		.thumb_func
 565              	uxTaskPriorityGet:
 566              	.LFB4:
 743:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 567              		.loc 1 743 0
 568              		.cfi_startproc
 569              		@ args = 0, pretend = 0, frame = 0
 570              		@ frame_needed = 0, uses_anonymous_args = 0
 571              	.LVL37:
 572 0000 10B5     		push	{r4, lr}
 573              	.LCFI3:
 574              		.cfi_def_cfa_offset 8
 743:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 575              		.loc 1 743 0
 576 0002 0446     		mov	r4, r0
 577              		.cfi_offset 14, -4
 578              		.cfi_offset 4, -8
 747:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
 579              		.loc 1 747 0
 580 0004 FFF7FEFF 		bl	vPortEnterCritical
 581              	.LVL38:
 751:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 582              		.loc 1 751 0
 583 0008 0CB9     		cbnz	r4, .L33
 751:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 584              		.loc 1 751 0 is_stmt 0 discriminator 1
 585 000a 034B     		ldr	r3, .L34
 586 000c 1C68     		ldr	r4, [r3, #0]
 587              	.LVL39:
 588              	.L33:
 752:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 589              		.loc 1 752 0 is_stmt 1 discriminator 3
 590 000e E46A     		ldr	r4, [r4, #44]
 591              	.LVL40:
 754:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
 592              		.loc 1 754 0 discriminator 3
 593 0010 FFF7FEFF 		bl	vPortExitCritical
 757:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 594              		.loc 1 757 0 discriminator 3
 595 0014 2046     		mov	r0, r4
 596 0016 10BD     		pop	{r4, pc}
 597              	.L35:
 598              		.align	2
 599              	.L34:
 600 0018 00000000 		.word	.LANCHOR2
 601              		.cfi_endproc
 602              	.LFE4:
 604              		.section	.text.vTaskPrioritySet,"ax",%progbits
 605              		.align	1
 606              		.global	vTaskPrioritySet
 607              		.thumb
 608              		.thumb_func
 610              	vTaskPrioritySet:
 611              	.LFB5:
 765:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 612              		.loc 1 765 0
 613              		.cfi_startproc
 614              		@ args = 0, pretend = 0, frame = 0
 615              		@ frame_needed = 0, uses_anonymous_args = 0
 616              	.LVL41:
 617 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 618              	.LCFI4:
 619              		.cfi_def_cfa_offset 24
 765:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 620              		.loc 1 765 0
 621 0004 0446     		mov	r4, r0
 622              		.cfi_offset 14, -4
 623              		.cfi_offset 8, -8
 624              		.cfi_offset 7, -12
 625              		.cfi_offset 6, -16
 626              		.cfi_offset 5, -20
 627              		.cfi_offset 4, -24
 784:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 628              		.loc 1 784 0
 629 0006 0429     		cmp	r1, #4
 630 0008 34BF     		ite	cc
 631 000a 0E46     		movcc	r6, r1
 632 000c 0426     		movcs	r6, #4
 633              	.LVL42:
 775:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
 634              		.loc 1 775 0
 635 000e FFF7FEFF 		bl	vPortEnterCritical
 636              	.LVL43:
 777:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 637              		.loc 1 777 0
 638 0012 1C4B     		ldr	r3, .L45
 639 0014 1A68     		ldr	r2, [r3, #0]
 640 0016 9442     		cmp	r4, r2
 641 0018 00D0     		beq	.L37
 784:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 642              		.loc 1 784 0
 643 001a 14B9     		cbnz	r4, .L38
 644              	.L37:
 784:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 645              		.loc 1 784 0 is_stmt 0 discriminator 1
 646 001c 1D68     		ldr	r5, [r3, #0]
 647 001e 0024     		movs	r4, #0
 648              	.LVL44:
 649 0020 00E0     		b	.L39
 650              	.LVL45:
 651              	.L38:
 784:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 652              		.loc 1 784 0 discriminator 2
 653 0022 2546     		mov	r5, r4
 654              	.LVL46:
 655              	.L39:
 794:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 656              		.loc 1 794 0 is_stmt 1 discriminator 3
 657 0024 EB6A     		ldr	r3, [r5, #44]
 658              	.LVL47:
 798:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 659              		.loc 1 798 0 discriminator 3
 660 0026 B342     		cmp	r3, r6
 661 0028 27D0     		beq	.L40
 802:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 662              		.loc 1 802 0
 663 002a 9E42     		cmp	r6, r3
 664 002c 03D9     		bls	.L41
 810:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 665              		.loc 1 810 0
 666 002e 003C     		subs	r4, r4, #0
 667 0030 18BF     		it	ne
 668 0032 0124     		movne	r4, #1
 669 0034 03E0     		b	.L42
 670              	.L41:
 671 0036 D4F10104 		rsbs	r4, r4, #1
 672 003a 38BF     		it	cc
 673 003c 0024     		movcc	r4, #0
 674              	.L42:
 675              	.LVL48:
 846:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 676              		.loc 1 846 0
 677 003e 124F     		ldr	r7, .L45+4
 678 0040 1422     		movs	r2, #20
 679 0042 02FB0373 		mla	r3, r2, r3, r7
 680 0046 6A69     		ldr	r2, [r5, #20]
 836:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 681              		.loc 1 836 0
 682 0048 EE62     		str	r6, [r5, #44]
 846:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 683              		.loc 1 846 0
 684 004a 9A42     		cmp	r2, r3
 840:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 685              		.loc 1 840 0
 686 004c C6F10506 		rsb	r6, r6, #5
 687              	.LVL49:
 688 0050 AE61     		str	r6, [r5, #24]
 846:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 689              		.loc 1 846 0
 690 0052 0FD1     		bne	.L43
 851:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 691              		.loc 1 851 0
 692 0054 2E1D     		adds	r6, r5, #4
 693 0056 3046     		mov	r0, r6
 694 0058 FFF7FEFF 		bl	vListRemove
 695              	.LVL50:
 852:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 696              		.loc 1 852 0
 697 005c 0B4A     		ldr	r2, .L45+8
 698 005e EB6A     		ldr	r3, [r5, #44]
 699 0060 1168     		ldr	r1, [r2, #0]
 700 0062 8B42     		cmp	r3, r1
 701 0064 88BF     		it	hi
 702 0066 1360     		strhi	r3, [r2, #0]
 703 0068 1420     		movs	r0, #20
 704 006a 00FB0370 		mla	r0, r0, r3, r7
 705 006e 3146     		mov	r1, r6
 706 0070 FFF7FEFF 		bl	vListInsertEnd
 707              	.L43:
 855:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 708              		.loc 1 855 0
 709 0074 0CB1     		cbz	r4, .L40
 857:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					portYIELD_WITHIN_API();
 710              		.loc 1 857 0
 711 0076 FFF7FEFF 		bl	vPortYieldFromISR
 712              	.LVL51:
 713              	.L40:
 862:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 714              		.loc 1 862 0
 715 007a BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 861:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
 716              		.loc 1 861 0
 717 007e FFF7FEBF 		b	vPortExitCritical
 718              	.L46:
 719 0082 00BF     		.align	2
 720              	.L45:
 721 0084 00000000 		.word	.LANCHOR2
 722 0088 00000000 		.word	.LANCHOR3
 723 008c 00000000 		.word	.LANCHOR14
 724              		.cfi_endproc
 725              	.LFE5:
 727              		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 728              		.align	1
 729              		.global	xTaskIsTaskSuspended
 730              		.thumb
 731              		.thumb_func
 733              	xTaskIsTaskSuspended:
 734              	.LFB7:
 934:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 735              		.loc 1 934 0
 736              		.cfi_startproc
 737              		@ args = 0, pretend = 0, frame = 0
 738              		@ frame_needed = 0, uses_anonymous_args = 0
 739              		@ link register save eliminated.
 740              	.LVL52:
 940:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 741              		.loc 1 940 0
 742 0000 4269     		ldr	r2, [r0, #20]
 743 0002 084B     		ldr	r3, .L51
 744 0004 9A42     		cmp	r2, r3
 745 0006 08D1     		bne	.L49
 943:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 746              		.loc 1 943 0
 747 0008 806A     		ldr	r0, [r0, #40]
 748              	.LVL53:
 749 000a 074B     		ldr	r3, .L51+4
 750 000c 9842     		cmp	r0, r3
 751 000e 06D0     		beq	.L50
 935:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 752              		.loc 1 935 0
 753 0010 D0F10100 		rsbs	r0, r0, #1
 754 0014 38BF     		it	cc
 755 0016 0020     		movcc	r0, #0
 756 0018 7047     		bx	lr
 757              	.LVL54:
 758              	.L49:
 759 001a 0020     		movs	r0, #0
 760              	.LVL55:
 761 001c 7047     		bx	lr
 762              	.L50:
 763 001e 0020     		movs	r0, #0
 764              	.LVL56:
 957:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 765              		.loc 1 957 0
 766 0020 7047     		bx	lr
 767              	.L52:
 768 0022 00BF     		.align	2
 769              	.L51:
 770 0024 00000000 		.word	.LANCHOR8
 771 0028 00000000 		.word	.LANCHOR6
 772              		.cfi_endproc
 773              	.LFE7:
 775              		.section	.text.vTaskResume,"ax",%progbits
 776              		.align	1
 777              		.global	vTaskResume
 778              		.thumb
 779              		.thumb_func
 781              	vTaskResume:
 782              	.LFB8:
 965:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 783              		.loc 1 965 0
 784              		.cfi_startproc
 785              		@ args = 0, pretend = 0, frame = 0
 786              		@ frame_needed = 0, uses_anonymous_args = 0
 787              	.LVL57:
 788 0000 70B5     		push	{r4, r5, r6, lr}
 789              	.LCFI5:
 790              		.cfi_def_cfa_offset 16
 974:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 791              		.loc 1 974 0
 792 0002 0446     		mov	r4, r0
 793              		.cfi_offset 14, -4
 794              		.cfi_offset 6, -8
 795              		.cfi_offset 5, -12
 796              		.cfi_offset 4, -16
 797 0004 0028     		cmp	r0, #0
 798 0006 26D0     		beq	.L53
 974:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 799              		.loc 1 974 0 is_stmt 0 discriminator 1
 800 0008 134D     		ldr	r5, .L57
 801 000a 2B68     		ldr	r3, [r5, #0]
 802 000c 9842     		cmp	r0, r3
 803 000e 22D0     		beq	.L53
 976:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			portENTER_CRITICAL();
 804              		.loc 1 976 0 is_stmt 1
 805 0010 FFF7FEFF 		bl	vPortEnterCritical
 806              	.LVL58:
 978:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 807              		.loc 1 978 0
 808 0014 2046     		mov	r0, r4
 809 0016 FFF7FEFF 		bl	xTaskIsTaskSuspended
 810 001a 0128     		cmp	r0, #1
 811 001c 17D1     		bne	.L55
 984:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 812              		.loc 1 984 0
 813 001e 261D     		adds	r6, r4, #4
 814 0020 3046     		mov	r0, r6
 815 0022 FFF7FEFF 		bl	vListRemove
 985:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 816              		.loc 1 985 0
 817 0026 0D4A     		ldr	r2, .L57+4
 818 0028 E36A     		ldr	r3, [r4, #44]
 819 002a 1168     		ldr	r1, [r2, #0]
 820 002c 8B42     		cmp	r3, r1
 821 002e 88BF     		it	hi
 822 0030 1360     		strhi	r3, [r2, #0]
 823 0032 0B4A     		ldr	r2, .L57+8
 824 0034 1420     		movs	r0, #20
 825 0036 00FB0320 		mla	r0, r0, r3, r2
 826 003a 3146     		mov	r1, r6
 827 003c FFF7FEFF 		bl	vListInsertEnd
 988:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 828              		.loc 1 988 0
 829 0040 2B68     		ldr	r3, [r5, #0]
 830 0042 E26A     		ldr	r2, [r4, #44]
 831 0044 DB6A     		ldr	r3, [r3, #44]
 832 0046 9A42     		cmp	r2, r3
 833 0048 01D3     		bcc	.L55
 992:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						portYIELD_WITHIN_API();
 834              		.loc 1 992 0
 835 004a FFF7FEFF 		bl	vPortYieldFromISR
 836              	.L55:
 998:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 837              		.loc 1 998 0
 838 004e BDE87040 		pop	{r4, r5, r6, lr}
 996:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			portEXIT_CRITICAL();
 839              		.loc 1 996 0
 840 0052 FFF7FEBF 		b	vPortExitCritical
 841              	.L53:
 842 0056 70BD     		pop	{r4, r5, r6, pc}
 843              	.L58:
 844              		.align	2
 845              	.L57:
 846 0058 00000000 		.word	.LANCHOR2
 847 005c 00000000 		.word	.LANCHOR14
 848 0060 00000000 		.word	.LANCHOR3
 849              		.cfi_endproc
 850              	.LFE8:
 852              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 853              		.align	1
 854              		.global	xTaskResumeFromISR
 855              		.thumb
 856              		.thumb_func
 858              	xTaskResumeFromISR:
 859              	.LFB9:
1007:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 860              		.loc 1 1007 0
 861              		.cfi_startproc
 862              		@ args = 0, pretend = 0, frame = 0
 863              		@ frame_needed = 0, uses_anonymous_args = 0
 864              	.LVL59:
 865 0000 70B5     		push	{r4, r5, r6, lr}
 866              	.LCFI6:
 867              		.cfi_def_cfa_offset 16
1007:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 868              		.loc 1 1007 0
 869 0002 0546     		mov	r5, r0
 870              		.cfi_offset 14, -4
 871              		.cfi_offset 6, -8
 872              		.cfi_offset 5, -12
 873              		.cfi_offset 4, -16
 874              	.LVL60:
1013:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 875              		.loc 1 1013 0
 876 0004 FFF7FEFF 		bl	xTaskIsTaskSuspended
 877              	.LVL61:
 878 0008 0128     		cmp	r0, #1
 879 000a 21D1     		bne	.L63
1017:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 880              		.loc 1 1017 0
 881 000c 124B     		ldr	r3, .L64
 882 000e 1B68     		ldr	r3, [r3, #0]
 883 0010 CBB9     		cbnz	r3, .L61
1019:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 884              		.loc 1 1019 0
 885 0012 124B     		ldr	r3, .L64+4
 886 0014 EC6A     		ldr	r4, [r5, #44]
 887 0016 1B68     		ldr	r3, [r3, #0]
 888 0018 DB6A     		ldr	r3, [r3, #44]
 889 001a 9C42     		cmp	r4, r3
 890 001c 34BF     		ite	cc
 891 001e 0024     		movcc	r4, #0
 892 0020 0124     		movcs	r4, #1
 893              	.LVL62:
1020:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 894              		.loc 1 1020 0
 895 0022 2E1D     		adds	r6, r5, #4
 896              	.LVL63:
 897 0024 3046     		mov	r0, r6
 898 0026 FFF7FEFF 		bl	vListRemove
1021:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 899              		.loc 1 1021 0
 900 002a 0D4A     		ldr	r2, .L64+8
 901 002c EB6A     		ldr	r3, [r5, #44]
 902 002e 1168     		ldr	r1, [r2, #0]
 903 0030 8B42     		cmp	r3, r1
 904 0032 88BF     		it	hi
 905 0034 1360     		strhi	r3, [r2, #0]
 906 0036 0B4A     		ldr	r2, .L64+12
 907 0038 1420     		movs	r0, #20
 908 003a 00FB0320 		mla	r0, r0, r3, r2
 909 003e 3146     		mov	r1, r6
 910 0040 FFF7FEFF 		bl	vListInsertEnd
 911 0044 05E0     		b	.L60
 912              	.LVL64:
 913              	.L61:
1028:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 914              		.loc 1 1028 0
 915 0046 0848     		ldr	r0, .L64+16
 916 0048 05F11801 		add	r1, r5, #24
 917 004c FFF7FEFF 		bl	vListInsertEnd
 918              	.L63:
1008:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 919              		.loc 1 1008 0
 920 0050 0024     		movs	r4, #0
 921              	.LVL65:
 922              	.L60:
1033:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 923              		.loc 1 1033 0
 924 0052 2046     		mov	r0, r4
 925 0054 70BD     		pop	{r4, r5, r6, pc}
 926              	.L65:
 927 0056 00BF     		.align	2
 928              	.L64:
 929 0058 00000000 		.word	.LANCHOR16
 930 005c 00000000 		.word	.LANCHOR2
 931 0060 00000000 		.word	.LANCHOR14
 932 0064 00000000 		.word	.LANCHOR3
 933 0068 00000000 		.word	.LANCHOR6
 934              		.cfi_endproc
 935              	.LFE9:
 937              		.section	.text.vTaskStartScheduler,"ax",%progbits
 938              		.align	1
 939              		.global	vTaskStartScheduler
 940              		.thumb
 941              		.thumb_func
 943              	vTaskStartScheduler:
 944              	.LFB10:
1046:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 945              		.loc 1 1046 0
 946              		.cfi_startproc
 947              		@ args = 0, pretend = 0, frame = 0
 948              		@ frame_needed = 0, uses_anonymous_args = 0
 949 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 950              	.LCFI7:
 951              		.cfi_def_cfa_offset 24
1050:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
 952              		.loc 1 1050 0
 953 0002 0024     		movs	r4, #0
 954              		.cfi_offset 14, -4
 955              		.cfi_offset 4, -8
 956              		.cfi_offset 3, -12
 957              		.cfi_offset 2, -16
 958              		.cfi_offset 1, -20
 959              		.cfi_offset 0, -24
 960 0004 8022     		movs	r2, #128
 961 0006 2346     		mov	r3, r4
 962 0008 0C48     		ldr	r0, .L68
 963 000a 0D49     		ldr	r1, .L68+4
 964 000c 0094     		str	r4, [sp, #0]
 965 000e 0194     		str	r4, [sp, #4]
 966 0010 0294     		str	r4, [sp, #8]
 967 0012 0394     		str	r4, [sp, #12]
 968 0014 FFF7FEFF 		bl	xTaskGenericCreate
1052:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( xReturn == pdPASS )
 969              		.loc 1 1052 0
 970 0018 0128     		cmp	r0, #1
1050:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
 971              		.loc 1 1050 0
 972 001a 0346     		mov	r3, r0
 973              	.LVL66:
1052:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( xReturn == pdPASS )
 974              		.loc 1 1052 0
 975 001c 0CD1     		bne	.L66
1062:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 976              		.loc 1 1062 0
 977              	@ 1062 "firmware/FreeRTOSV6.1.0/Source/tasks.c" 1
 978 001e 4FF0BF00 			mov r0, #191								
 979 0022 80F31188 		msr basepri, r0							
 980              	
 981              	@ 0 "" 2
 982              	.LVL67:
1064:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 983              		.loc 1 1064 0
 984              		.thumb
 985 0026 074A     		ldr	r2, .L68+8
 986 0028 1360     		str	r3, [r2, #0]
1065:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xTickCount = ( portTickType ) 0;
 987              		.loc 1 1065 0
 988 002a 074B     		ldr	r3, .L68+12
 989              	.LVL68:
 990 002c 1C60     		str	r4, [r3, #0]
1084:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 991              		.loc 1 1084 0
 992 002e 04B0     		add	sp, sp, #16
 993 0030 BDE81040 		pop	{r4, lr}
1074:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xPortStartScheduler() )
 994              		.loc 1 1074 0
 995 0034 FFF7FEBF 		b	xPortStartScheduler
 996              	.LVL69:
 997              	.L66:
1084:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 998              		.loc 1 1084 0
 999 0038 04B0     		add	sp, sp, #16
 1000 003a 10BD     		pop	{r4, pc}
 1001              	.L69:
 1002              		.align	2
 1003              	.L68:
 1004 003c 00000000 		.word	prvIdleTask
 1005 0040 12000000 		.word	.LC1
 1006 0044 00000000 		.word	.LANCHOR11
 1007 0048 00000000 		.word	.LANCHOR17
 1008              		.cfi_endproc
 1009              	.LFE10:
 1011              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1012              		.align	1
 1013              		.global	vTaskEndScheduler
 1014              		.thumb
 1015              		.thumb_func
 1017              	vTaskEndScheduler:
 1018              	.LFB11:
1088:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 1019              		.loc 1 1088 0
 1020              		.cfi_startproc
 1021              		@ args = 0, pretend = 0, frame = 0
 1022              		@ frame_needed = 0, uses_anonymous_args = 0
 1023              		@ link register save eliminated.
1092:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1024              		.loc 1 1092 0
 1025              	@ 1092 "firmware/FreeRTOSV6.1.0/Source/tasks.c" 1
 1026 0000 4FF0BF00 			mov r0, #191								
 1027 0004 80F31188 		msr basepri, r0							
 1028              	
 1029              	@ 0 "" 2
1093:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1030              		.loc 1 1093 0
 1031              		.thumb
 1032 0008 024B     		ldr	r3, .L71
 1033 000a 0022     		movs	r2, #0
 1034 000c 1A60     		str	r2, [r3, #0]
1095:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 1035              		.loc 1 1095 0
1094:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vPortEndScheduler();
 1036              		.loc 1 1094 0
 1037 000e FFF7FEBF 		b	vPortEndScheduler
 1038              	.L72:
 1039 0012 00BF     		.align	2
 1040              	.L71:
 1041 0014 00000000 		.word	.LANCHOR11
 1042              		.cfi_endproc
 1043              	.LFE11:
 1045              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1046              		.align	1
 1047              		.global	vTaskSuspendAll
 1048              		.thumb
 1049              		.thumb_func
 1051              	vTaskSuspendAll:
 1052              	.LFB12:
1099:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 1053              		.loc 1 1099 0
 1054              		.cfi_startproc
 1055              		@ args = 0, pretend = 0, frame = 0
 1056              		@ frame_needed = 0, uses_anonymous_args = 0
 1057              		@ link register save eliminated.
1102:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	++uxSchedulerSuspended;
 1058              		.loc 1 1102 0
 1059 0000 024B     		ldr	r3, .L74
 1060 0002 1A68     		ldr	r2, [r3, #0]
 1061 0004 0132     		adds	r2, r2, #1
 1062 0006 1A60     		str	r2, [r3, #0]
1103:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 1063              		.loc 1 1103 0
 1064 0008 7047     		bx	lr
 1065              	.L75:
 1066 000a 00BF     		.align	2
 1067              	.L74:
 1068 000c 00000000 		.word	.LANCHOR16
 1069              		.cfi_endproc
 1070              	.LFE12:
 1072              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1073              		.align	1
 1074              		.global	xTaskGetTickCount
 1075              		.thumb
 1076              		.thumb_func
 1078              	xTaskGetTickCount:
 1079              	.LFB14:
1189:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 1080              		.loc 1 1189 0
 1081              		.cfi_startproc
 1082              		@ args = 0, pretend = 0, frame = 0
 1083              		@ frame_needed = 0, uses_anonymous_args = 0
 1084 0000 10B5     		push	{r4, lr}
 1085              	.LCFI8:
 1086              		.cfi_def_cfa_offset 8
1193:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portENTER_CRITICAL();
 1087              		.loc 1 1193 0
 1088              		.cfi_offset 14, -4
 1089              		.cfi_offset 4, -8
 1090 0002 FFF7FEFF 		bl	vPortEnterCritical
1195:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xTicks = xTickCount;
 1091              		.loc 1 1195 0
 1092 0006 034B     		ldr	r3, .L77
 1093 0008 1C68     		ldr	r4, [r3, #0]
 1094              	.LVL70:
1197:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portEXIT_CRITICAL();
 1095              		.loc 1 1197 0
 1096 000a FFF7FEFF 		bl	vPortExitCritical
1200:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 1097              		.loc 1 1200 0
 1098 000e 2046     		mov	r0, r4
 1099 0010 10BD     		pop	{r4, pc}
 1100              	.L78:
 1101 0012 00BF     		.align	2
 1102              	.L77:
 1103 0014 00000000 		.word	.LANCHOR17
 1104              		.cfi_endproc
 1105              	.LFE14:
 1107              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1108              		.align	1
 1109              		.global	xTaskGetTickCountFromISR
 1110              		.thumb
 1111              		.thumb_func
 1113              	xTaskGetTickCountFromISR:
 1114              	.LFB15:
1204:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 1115              		.loc 1 1204 0
 1116              		.cfi_startproc
 1117              		@ args = 0, pretend = 0, frame = 0
 1118              		@ frame_needed = 0, uses_anonymous_args = 0
 1119              		@ link register save eliminated.
1205:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	return xTickCount;
 1120              		.loc 1 1205 0
 1121 0000 014B     		ldr	r3, .L80
 1122 0002 1868     		ldr	r0, [r3, #0]
1206:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 1123              		.loc 1 1206 0
 1124 0004 7047     		bx	lr
 1125              	.L81:
 1126 0006 00BF     		.align	2
 1127              	.L80:
 1128 0008 00000000 		.word	.LANCHOR17
 1129              		.cfi_endproc
 1130              	.LFE15:
 1132              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1133              		.align	1
 1134              		.global	uxTaskGetNumberOfTasks
 1135              		.thumb
 1136              		.thumb_func
 1138              	uxTaskGetNumberOfTasks:
 1139              	.LFB16:
1210:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 1140              		.loc 1 1210 0
 1141              		.cfi_startproc
 1142              		@ args = 0, pretend = 0, frame = 0
 1143              		@ frame_needed = 0, uses_anonymous_args = 0
 1144              		@ link register save eliminated.
1213:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1145              		.loc 1 1213 0
 1146 0000 014B     		ldr	r3, .L83
 1147 0002 1868     		ldr	r0, [r3, #0]
1214:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 1148              		.loc 1 1214 0
 1149 0004 7047     		bx	lr
 1150              	.L84:
 1151 0006 00BF     		.align	2
 1152              	.L83:
 1153 0008 00000000 		.word	.LANCHOR1
 1154              		.cfi_endproc
 1155              	.LFE16:
 1157              		.section	.text.vTaskStartTrace,"ax",%progbits
 1158              		.align	1
 1159              		.global	vTaskStartTrace
 1160              		.thumb
 1161              		.thumb_func
 1163              	vTaskStartTrace:
 1164              	.LFB18:
1348:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 1165              		.loc 1 1348 0
 1166              		.cfi_startproc
 1167              		@ args = 0, pretend = 0, frame = 0
 1168              		@ frame_needed = 0, uses_anonymous_args = 0
 1169              	.LVL71:
 1170 0000 70B5     		push	{r4, r5, r6, lr}
 1171              	.LCFI9:
 1172              		.cfi_def_cfa_offset 16
1348:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 1173              		.loc 1 1348 0
 1174 0002 0446     		mov	r4, r0
 1175              		.cfi_offset 14, -4
 1176              		.cfi_offset 6, -8
 1177              		.cfi_offset 5, -12
 1178              		.cfi_offset 4, -16
 1179 0004 0D46     		mov	r5, r1
1349:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
 1180              		.loc 1 1349 0
 1181 0006 FFF7FEFF 		bl	vPortEnterCritical
 1182              	.LVL72:
1351:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
 1183              		.loc 1 1351 0
 1184 000a 084B     		ldr	r3, .L86
1353:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
 1185              		.loc 1 1353 0
 1186 000c A5F10801 		sub	r1, r5, #8
1351:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
 1187              		.loc 1 1351 0
 1188 0010 1C60     		str	r4, [r3, #0]
1352:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
 1189              		.loc 1 1352 0
 1190 0012 074B     		ldr	r3, .L86+4
1354:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTracing = pdTRUE;
 1191              		.loc 1 1354 0
 1192 0014 0122     		movs	r2, #1
1352:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
 1193              		.loc 1 1352 0
 1194 0016 1C60     		str	r4, [r3, #0]
1353:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
 1195              		.loc 1 1353 0
 1196 0018 064B     		ldr	r3, .L86+8
 1197 001a 6418     		adds	r4, r4, r1
 1198              	.LVL73:
 1199 001c 1C60     		str	r4, [r3, #0]
1354:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTracing = pdTRUE;
 1200              		.loc 1 1354 0
 1201 001e 064B     		ldr	r3, .L86+12
 1202 0020 1A60     		str	r2, [r3, #0]
1357:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 1203              		.loc 1 1357 0
 1204 0022 BDE87040 		pop	{r4, r5, r6, lr}
1356:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
 1205              		.loc 1 1356 0
 1206 0026 FFF7FEBF 		b	vPortExitCritical
 1207              	.LVL74:
 1208              	.L87:
 1209 002a 00BF     		.align	2
 1210              	.L86:
 1211 002c 00000000 		.word	.LANCHOR18
 1212 0030 00000000 		.word	.LANCHOR19
 1213 0034 00000000 		.word	.LANCHOR20
 1214 0038 00000000 		.word	.LANCHOR21
 1215              		.cfi_endproc
 1216              	.LFE18:
 1218              		.section	.text.ulTaskEndTrace,"ax",%progbits
 1219              		.align	1
 1220              		.global	ulTaskEndTrace
 1221              		.thumb
 1222              		.thumb_func
 1224              	ulTaskEndTrace:
 1225              	.LFB19:
1365:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 1226              		.loc 1 1365 0
 1227              		.cfi_startproc
 1228              		@ args = 0, pretend = 0, frame = 0
 1229              		@ frame_needed = 0, uses_anonymous_args = 0
 1230 0000 08B5     		push	{r3, lr}
 1231              	.LCFI10:
 1232              		.cfi_def_cfa_offset 8
1368:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
 1233              		.loc 1 1368 0
 1234              		.cfi_offset 14, -4
 1235              		.cfi_offset 3, -8
 1236 0002 FFF7FEFF 		bl	vPortEnterCritical
1369:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTracing = pdFALSE;
 1237              		.loc 1 1369 0
 1238 0006 054B     		ldr	r3, .L89
 1239 0008 0022     		movs	r2, #0
 1240 000a 1A60     		str	r2, [r3, #0]
1370:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
 1241              		.loc 1 1370 0
 1242 000c FFF7FEFF 		bl	vPortExitCritical
1372:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
 1243              		.loc 1 1372 0
 1244 0010 034B     		ldr	r3, .L89+4
 1245 0012 1868     		ldr	r0, [r3, #0]
 1246              	.LVL75:
 1247 0014 034B     		ldr	r3, .L89+8
 1248 0016 1B68     		ldr	r3, [r3, #0]
1375:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 1249              		.loc 1 1375 0
 1250 0018 C01A     		subs	r0, r0, r3
 1251              	.LVL76:
 1252 001a 08BD     		pop	{r3, pc}
 1253              	.L90:
 1254              		.align	2
 1255              	.L89:
 1256 001c 00000000 		.word	.LANCHOR21
 1257 0020 00000000 		.word	.LANCHOR18
 1258 0024 00000000 		.word	.LANCHOR19
 1259              		.cfi_endproc
 1260              	.LFE19:
 1262              		.section	.text.vTaskIncrementTick,"ax",%progbits
 1263              		.align	1
 1264              		.global	vTaskIncrementTick
 1265              		.thumb
 1266              		.thumb_func
 1268              	vTaskIncrementTick:
 1269              	.LFB20:
1388:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 1270              		.loc 1 1388 0
 1271              		.cfi_startproc
 1272              		@ args = 0, pretend = 0, frame = 0
 1273              		@ frame_needed = 0, uses_anonymous_args = 0
 1274 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1275              	.LCFI11:
 1276              		.cfi_def_cfa_offset 24
1392:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1277              		.loc 1 1392 0
 1278 0002 1F4B     		ldr	r3, .L99
 1279              		.cfi_offset 14, -4
 1280              		.cfi_offset 7, -8
 1281              		.cfi_offset 6, -12
 1282              		.cfi_offset 5, -16
 1283              		.cfi_offset 4, -20
 1284              		.cfi_offset 3, -24
 1285 0004 1B68     		ldr	r3, [r3, #0]
 1286 0006 002B     		cmp	r3, #0
 1287 0008 35D1     		bne	.L92
1394:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		++xTickCount;
 1288              		.loc 1 1394 0
 1289 000a 1E4D     		ldr	r5, .L99+4
 1290 000c 1E4C     		ldr	r4, .L99+8
 1291 000e 2B68     		ldr	r3, [r5, #0]
 1292 0010 0133     		adds	r3, r3, #1
 1293 0012 2B60     		str	r3, [r5, #0]
1395:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0 )
 1294              		.loc 1 1395 0
 1295 0014 2B68     		ldr	r3, [r5, #0]
 1296 0016 23BB     		cbnz	r3, .L94
 1297              	.LBB39:
1403:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1298              		.loc 1 1403 0
 1299 0018 1C4B     		ldr	r3, .L99+12
1402:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 1300              		.loc 1 1402 0
 1301 001a 2268     		ldr	r2, [r4, #0]
 1302              	.LVL77:
1403:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1303              		.loc 1 1403 0
 1304 001c 1968     		ldr	r1, [r3, #0]
 1305 001e 2160     		str	r1, [r4, #0]
1404:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 1306              		.loc 1 1404 0
 1307 0020 1A60     		str	r2, [r3, #0]
1405:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xNumOfOverflows++;
 1308              		.loc 1 1405 0
 1309 0022 1B4B     		ldr	r3, .L99+16
 1310 0024 1A68     		ldr	r2, [r3, #0]
 1311              	.LVL78:
 1312 0026 0132     		adds	r2, r2, #1
 1313 0028 1A60     		str	r2, [r3, #0]
 1314 002a 1AE0     		b	.L94
 1315              	.LVL79:
 1316              	.L98:
 1317              	.LBE39:
 1318              	.LBB40:
1409:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		prvCheckDelayedTasks();
 1319              		.loc 1 1409 0 discriminator 10
 1320 002c 2A68     		ldr	r2, [r5, #0]
 1321 002e 7368     		ldr	r3, [r6, #4]
 1322 0030 9A42     		cmp	r2, r3
 1323 0032 24D3     		bcc	.L91
1409:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		prvCheckDelayedTasks();
 1324              		.loc 1 1409 0 is_stmt 0 discriminator 2
 1325 0034 371D     		adds	r7, r6, #4
 1326 0036 3846     		mov	r0, r7
 1327 0038 FFF7FEFF 		bl	vListRemove
 1328 003c B36A     		ldr	r3, [r6, #40]
 1329 003e 1BB1     		cbz	r3, .L96
1409:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		prvCheckDelayedTasks();
 1330              		.loc 1 1409 0 discriminator 3
 1331 0040 06F11800 		add	r0, r6, #24
 1332 0044 FFF7FEFF 		bl	vListRemove
 1333              	.L96:
1409:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		prvCheckDelayedTasks();
 1334              		.loc 1 1409 0 discriminator 4
 1335 0048 124A     		ldr	r2, .L99+20
 1336 004a F36A     		ldr	r3, [r6, #44]
 1337 004c 1168     		ldr	r1, [r2, #0]
 1338 004e 8B42     		cmp	r3, r1
 1339 0050 88BF     		it	hi
 1340 0052 1360     		strhi	r3, [r2, #0]
 1341 0054 104A     		ldr	r2, .L99+24
 1342 0056 1420     		movs	r0, #20
 1343 0058 00FB0320 		mla	r0, r0, r3, r2
 1344 005c 3946     		mov	r1, r7
 1345 005e FFF7FEFF 		bl	vListInsertEnd
 1346              	.LVL80:
 1347              	.L94:
1409:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		prvCheckDelayedTasks();
 1348              		.loc 1 1409 0 discriminator 1
 1349 0062 2368     		ldr	r3, [r4, #0]
 1350 0064 1B68     		ldr	r3, [r3, #0]
 1351 0066 53B1     		cbz	r3, .L91
1409:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		prvCheckDelayedTasks();
 1352              		.loc 1 1409 0 discriminator 7
 1353 0068 074B     		ldr	r3, .L99+8
 1354 006a 1B68     		ldr	r3, [r3, #0]
 1355 006c DB68     		ldr	r3, [r3, #12]
 1356 006e DE68     		ldr	r6, [r3, #12]
 1357              	.LVL81:
 1358 0070 002E     		cmp	r6, #0
 1359 0072 DBD1     		bne	.L98
 1360 0074 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1361              	.LVL82:
 1362              	.L92:
 1363              	.LBE40:
1413:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		++uxMissedTicks;
 1364              		.loc 1 1413 0 is_stmt 1
 1365 0076 094B     		ldr	r3, .L99+28
 1366 0078 1A68     		ldr	r2, [r3, #0]
 1367 007a 0132     		adds	r2, r2, #1
 1368 007c 1A60     		str	r2, [r3, #0]
 1369              	.L91:
 1370 007e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1371              	.L100:
 1372              		.align	2
 1373              	.L99:
 1374 0080 00000000 		.word	.LANCHOR16
 1375 0084 00000000 		.word	.LANCHOR17
 1376 0088 00000000 		.word	.LANCHOR9
 1377 008c 00000000 		.word	.LANCHOR10
 1378 0090 00000000 		.word	.LANCHOR22
 1379 0094 00000000 		.word	.LANCHOR14
 1380 0098 00000000 		.word	.LANCHOR3
 1381 009c 00000000 		.word	.LANCHOR23
 1382              		.cfi_endproc
 1383              	.LFE20:
 1385              		.section	.text.xTaskResumeAll,"ax",%progbits
 1386              		.align	1
 1387              		.global	xTaskResumeAll
 1388              		.thumb
 1389              		.thumb_func
 1391              	xTaskResumeAll:
 1392              	.LFB13:
1107:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 1393              		.loc 1 1107 0
 1394              		.cfi_startproc
 1395              		@ args = 0, pretend = 0, frame = 0
 1396              		@ frame_needed = 0, uses_anonymous_args = 0
 1397              	.LVL83:
 1398 0000 70B5     		push	{r4, r5, r6, lr}
 1399              	.LCFI12:
 1400              		.cfi_def_cfa_offset 16
1116:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portENTER_CRITICAL();
 1401              		.loc 1 1116 0
 1402              		.cfi_offset 14, -4
 1403              		.cfi_offset 6, -8
 1404              		.cfi_offset 5, -12
 1405              		.cfi_offset 4, -16
 1406 0002 FFF7FEFF 		bl	vPortEnterCritical
1118:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		--uxSchedulerSuspended;
 1407              		.loc 1 1118 0
 1408 0006 274B     		ldr	r3, .L119
 1409 0008 1A68     		ldr	r2, [r3, #0]
 1410 000a 013A     		subs	r2, r2, #1
 1411 000c 1A60     		str	r2, [r3, #0]
1120:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1412              		.loc 1 1120 0
 1413 000e 1D68     		ldr	r5, [r3, #0]
 1414 0010 002D     		cmp	r5, #0
 1415 0012 41D1     		bne	.L112
1122:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 1416              		.loc 1 1122 0
 1417 0014 244B     		ldr	r3, .L119+4
 1418 0016 1C68     		ldr	r4, [r3, #0]
 1419 0018 E4B9     		cbnz	r4, .L116
 1420 001a 3EE0     		b	.L102
 1421              	.LVL84:
 1422              	.L107:
 1423              	.LBB41:
1131:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1424              		.loc 1 1131 0
 1425 001c 261D     		adds	r6, r4, #4
1130:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1426              		.loc 1 1130 0
 1427 001e 04F11800 		add	r0, r4, #24
 1428 0022 FFF7FEFF 		bl	vListRemove
1131:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1429              		.loc 1 1131 0
 1430 0026 3046     		mov	r0, r6
 1431 0028 FFF7FEFF 		bl	vListRemove
1132:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1432              		.loc 1 1132 0
 1433 002c 1F4A     		ldr	r2, .L119+8
 1434 002e E36A     		ldr	r3, [r4, #44]
 1435 0030 1168     		ldr	r1, [r2, #0]
 1436 0032 8B42     		cmp	r3, r1
 1437 0034 88BF     		it	hi
 1438 0036 1360     		strhi	r3, [r2, #0]
 1439 0038 1D4A     		ldr	r2, .L119+12
 1440 003a 1420     		movs	r0, #20
 1441 003c 00FB0320 		mla	r0, r0, r3, r2
 1442 0040 3146     		mov	r1, r6
 1443 0042 FFF7FEFF 		bl	vListInsertEnd
1136:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1444              		.loc 1 1136 0
 1445 0046 1B4B     		ldr	r3, .L119+16
 1446 0048 E26A     		ldr	r2, [r4, #44]
 1447 004a 1B68     		ldr	r3, [r3, #0]
 1448 004c DB6A     		ldr	r3, [r3, #44]
1138:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1449              		.loc 1 1138 0
 1450 004e 9A42     		cmp	r2, r3
 1451 0050 28BF     		it	cs
 1452 0052 0125     		movcs	r5, #1
 1453              	.LVL85:
 1454              	.L116:
1128:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
 1455              		.loc 1 1128 0 discriminator 1
 1456 0054 184B     		ldr	r3, .L119+20
 1457 0056 1A68     		ldr	r2, [r3, #0]
 1458 0058 1AB1     		cbz	r2, .L106
 1459 005a DB68     		ldr	r3, [r3, #12]
 1460 005c DC68     		ldr	r4, [r3, #12]
 1461              	.LVL86:
 1462 005e 002C     		cmp	r4, #0
 1463 0060 DCD1     		bne	.L107
 1464              	.LVL87:
 1465              	.L106:
1145:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 1466              		.loc 1 1145 0
 1467 0062 164E     		ldr	r6, .L119+24
 1468 0064 3468     		ldr	r4, [r6, #0]
 1469 0066 2CB9     		cbnz	r4, .L108
 1470 0068 09E0     		b	.L118
 1471              	.L110:
1149:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						vTaskIncrementTick();
 1472              		.loc 1 1149 0
 1473 006a FFF7FEFF 		bl	vTaskIncrementTick
1150:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 						--uxMissedTicks;
 1474              		.loc 1 1150 0
 1475 006e 2368     		ldr	r3, [r4, #0]
 1476 0070 013B     		subs	r3, r3, #1
 1477 0072 2360     		str	r3, [r4, #0]
 1478              	.L108:
1147:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 1479              		.loc 1 1147 0 discriminator 1
 1480 0074 3368     		ldr	r3, [r6, #0]
 1481 0076 114C     		ldr	r4, .L119+24
 1482 0078 002B     		cmp	r3, #0
 1483 007a F6D1     		bne	.L110
 1484 007c 05E0     		b	.L111
 1485              	.L118:
1163:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1486              		.loc 1 1163 0
 1487 007e 012D     		cmp	r5, #1
 1488 0080 03D0     		beq	.L111
1163:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1489              		.loc 1 1163 0 is_stmt 0 discriminator 1
 1490 0082 0F4B     		ldr	r3, .L119+28
 1491 0084 1B68     		ldr	r3, [r3, #0]
 1492 0086 012B     		cmp	r3, #1
 1493 0088 07D1     		bne	.L102
 1494              	.L111:
 1495              	.LVL88:
1166:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					xMissedYield = pdFALSE;
 1496              		.loc 1 1166 0 is_stmt 1
 1497 008a 0D4B     		ldr	r3, .L119+28
 1498 008c 0022     		movs	r2, #0
 1499 008e 1A60     		str	r2, [r3, #0]
1167:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					portYIELD_WITHIN_API();
 1500              		.loc 1 1167 0
 1501 0090 FFF7FEFF 		bl	vPortYieldFromISR
1165:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1502              		.loc 1 1165 0
 1503 0094 0124     		movs	r4, #1
 1504 0096 00E0     		b	.L102
 1505              	.LVL89:
 1506              	.L112:
 1507              	.LBE41:
1109:firmware/FreeRTOSV6.1.0/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1508              		.loc 1 1109 0
 1509 0098 0024     		movs	r4, #0
 1510              	.LVL90:
 1511              	.L102:
1172:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portEXIT_CRITICAL();
 1512              		.loc 1 1172 0
 1513 009a FFF7FEFF 		bl	vPortExitCritical
1175:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 1514              		.loc 1 1175 0
 1515 009e 2046     		mov	r0, r4
 1516 00a0 70BD     		pop	{r4, r5, r6, pc}
 1517              	.L120:
 1518 00a2 00BF     		.align	2
 1519              	.L119:
 1520 00a4 00000000 		.word	.LANCHOR16
 1521 00a8 00000000 		.word	.LANCHOR1
 1522 00ac 00000000 		.word	.LANCHOR14
 1523 00b0 00000000 		.word	.LANCHOR3
 1524 00b4 00000000 		.word	.LANCHOR2
 1525 00b8 00000000 		.word	.LANCHOR6
 1526 00bc 00000000 		.word	.LANCHOR23
 1527 00c0 00000000 		.word	.LANCHOR24
 1528              		.cfi_endproc
 1529              	.LFE13:
 1531              		.section	.text.vTaskList,"ax",%progbits
 1532              		.align	1
 1533              		.global	vTaskList
 1534              		.thumb
 1535              		.thumb_func
 1537              	vTaskList:
 1538              	.LFB17:
1220:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 1539              		.loc 1 1220 0
 1540              		.cfi_startproc
 1541              		@ args = 0, pretend = 0, frame = 0
 1542              		@ frame_needed = 0, uses_anonymous_args = 0
 1543              	.LVL91:
 1544 0000 70B5     		push	{r4, r5, r6, lr}
 1545              	.LCFI13:
 1546              		.cfi_def_cfa_offset 16
1220:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 1547              		.loc 1 1220 0
 1548 0002 0446     		mov	r4, r0
 1549              		.cfi_offset 14, -4
 1550              		.cfi_offset 6, -8
 1551              		.cfi_offset 5, -12
 1552              		.cfi_offset 4, -16
1226:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vTaskSuspendAll();
 1553              		.loc 1 1226 0
 1554 0004 FFF7FEFF 		bl	vTaskSuspendAll
 1555              	.LVL92:
1231:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
 1556              		.loc 1 1231 0
 1557 0008 0023     		movs	r3, #0
 1558 000a 2370     		strb	r3, [r4, #0]
1232:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 1559              		.loc 1 1232 0
 1560 000c 2046     		mov	r0, r4
 1561 000e 1B49     		ldr	r1, .L128
 1562 0010 FFF7FEFF 		bl	strcat
1234:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
 1563              		.loc 1 1234 0
 1564 0014 1A4B     		ldr	r3, .L128+4
 1565 0016 1D68     		ldr	r5, [r3, #0]
 1566 0018 0135     		adds	r5, r5, #1
 1567              	.LVL93:
 1568              	.L123:
1238:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				uxQueue--;
 1569              		.loc 1 1238 0
 1570 001a 013D     		subs	r5, r5, #1
 1571              	.LVL94:
1240:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
 1572              		.loc 1 1240 0
 1573 001c 1423     		movs	r3, #20
 1574 001e 6B43     		muls	r3, r5, r3
 1575 0020 184A     		ldr	r2, .L128+8
 1576 0022 D118     		adds	r1, r2, r3
 1577 0024 D358     		ldr	r3, [r2, r3]
 1578 0026 1BB1     		cbz	r3, .L122
1242:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
 1579              		.loc 1 1242 0
 1580 0028 2046     		mov	r0, r4
 1581 002a 5222     		movs	r2, #82
 1582 002c FFF7FEFF 		bl	prvListTaskWithinSingleList
 1583              	.L122:
1244:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 1584              		.loc 1 1244 0
 1585 0030 002D     		cmp	r5, #0
 1586 0032 F2D1     		bne	.L123
1246:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
 1587              		.loc 1 1246 0
 1588 0034 144B     		ldr	r3, .L128+12
 1589 0036 1A68     		ldr	r2, [r3, #0]
 1590 0038 1268     		ldr	r2, [r2, #0]
 1591 003a 22B1     		cbz	r2, .L124
1248:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
 1592              		.loc 1 1248 0
 1593 003c 1968     		ldr	r1, [r3, #0]
 1594 003e 2046     		mov	r0, r4
 1595 0040 4222     		movs	r2, #66
 1596 0042 FFF7FEFF 		bl	prvListTaskWithinSingleList
 1597              	.L124:
1251:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
 1598              		.loc 1 1251 0
 1599 0046 114B     		ldr	r3, .L128+16
 1600 0048 1A68     		ldr	r2, [r3, #0]
 1601 004a 1268     		ldr	r2, [r2, #0]
 1602 004c 22B1     		cbz	r2, .L125
1253:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
 1603              		.loc 1 1253 0
 1604 004e 1968     		ldr	r1, [r3, #0]
 1605 0050 2046     		mov	r0, r4
 1606 0052 4222     		movs	r2, #66
 1607 0054 FFF7FEFF 		bl	prvListTaskWithinSingleList
 1608              	.L125:
1258:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
 1609              		.loc 1 1258 0
 1610 0058 0D49     		ldr	r1, .L128+20
 1611 005a 0B68     		ldr	r3, [r1, #0]
 1612 005c 1BB1     		cbz	r3, .L126
1260:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, tskDELETED_
 1613              		.loc 1 1260 0
 1614 005e 2046     		mov	r0, r4
 1615 0060 4422     		movs	r2, #68
 1616 0062 FFF7FEFF 		bl	prvListTaskWithinSingleList
 1617              	.L126:
1267:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
 1618              		.loc 1 1267 0
 1619 0066 0B49     		ldr	r1, .L128+24
 1620 0068 0B68     		ldr	r3, [r1, #0]
 1621 006a 1BB1     		cbz	r3, .L127
1269:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
 1622              		.loc 1 1269 0
 1623 006c 2046     		mov	r0, r4
 1624 006e 5322     		movs	r2, #83
 1625 0070 FFF7FEFF 		bl	prvListTaskWithinSingleList
 1626              	.L127:
1275:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 1627              		.loc 1 1275 0
 1628 0074 BDE87040 		pop	{r4, r5, r6, lr}
1274:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xTaskResumeAll();
 1629              		.loc 1 1274 0
 1630 0078 FFF7FEBF 		b	xTaskResumeAll
 1631              	.L129:
 1632              		.align	2
 1633              	.L128:
 1634 007c 17000000 		.word	.LC2
 1635 0080 00000000 		.word	.LANCHOR12
 1636 0084 00000000 		.word	.LANCHOR3
 1637 0088 00000000 		.word	.LANCHOR9
 1638 008c 00000000 		.word	.LANCHOR10
 1639 0090 00000000 		.word	.LANCHOR7
 1640 0094 00000000 		.word	.LANCHOR8
 1641              		.cfi_endproc
 1642              	.LFE17:
 1644              		.section	.text.prvIdleTask,"ax",%progbits
 1645              		.align	1
 1646              		.thumb
 1647              		.thumb_func
 1649              	prvIdleTask:
 1650              	.LFB27:
1811:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 1651              		.loc 1 1811 0
 1652              		.cfi_startproc
 1653              		@ args = 0, pretend = 0, frame = 0
 1654              		@ frame_needed = 0, uses_anonymous_args = 0
 1655              	.LVL95:
 1656 0000 70B5     		push	{r4, r5, r6, lr}
 1657              	.LCFI14:
 1658              		.cfi_def_cfa_offset 16
 1659              	.LVL96:
 1660              	.L137:
 1661              	.LBB48:
 1662              	.LBB49:
2001:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 1663              		.loc 1 2001 0
 1664 0002 144D     		ldr	r5, .L138
 1665              		.cfi_offset 14, -4
 1666              		.cfi_offset 6, -8
 1667              		.cfi_offset 5, -12
 1668              		.cfi_offset 4, -16
 1669 0004 2B68     		ldr	r3, [r5, #0]
 1670 0006 F3B1     		cbz	r3, .L131
2004:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 1671              		.loc 1 2004 0
 1672 0008 134E     		ldr	r6, .L138+4
2003:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vTaskSuspendAll();
 1673              		.loc 1 2003 0
 1674 000a FFF7FEFF 		bl	vTaskSuspendAll
2004:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 1675              		.loc 1 2004 0
 1676 000e 3468     		ldr	r4, [r6, #0]
 1677              	.LVL97:
2005:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTaskResumeAll();
 1678              		.loc 1 2005 0
 1679 0010 FFF7FEFF 		bl	xTaskResumeAll
2007:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( !xListIsEmpty )
 1680              		.loc 1 2007 0
 1681 0014 BCB1     		cbz	r4, .L131
 1682              	.LBB50:
2011:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				portENTER_CRITICAL();
 1683              		.loc 1 2011 0
 1684 0016 FFF7FEFF 		bl	vPortEnterCritical
2013:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 1685              		.loc 1 2013 0
 1686 001a 3468     		ldr	r4, [r6, #0]
 1687              	.LVL98:
 1688 001c 0CB1     		cbz	r4, .L132
 1689 001e F368     		ldr	r3, [r6, #12]
 1690 0020 DC68     		ldr	r4, [r3, #12]
 1691              	.L132:
 1692              	.LVL99:
2014:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1693              		.loc 1 2014 0
 1694 0022 201D     		adds	r0, r4, #4
 1695 0024 FFF7FEFF 		bl	vListRemove
2015:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 1696              		.loc 1 2015 0
 1697 0028 0C4B     		ldr	r3, .L138+8
 1698 002a 1A68     		ldr	r2, [r3, #0]
 1699 002c 013A     		subs	r2, r2, #1
 1700 002e 1A60     		str	r2, [r3, #0]
2016:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					--uxTasksDeleted;
 1701              		.loc 1 2016 0
 1702 0030 2B68     		ldr	r3, [r5, #0]
 1703 0032 013B     		subs	r3, r3, #1
 1704 0034 2B60     		str	r3, [r5, #0]
2018:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				portEXIT_CRITICAL();
 1705              		.loc 1 2018 0
 1706 0036 FFF7FEFF 		bl	vPortExitCritical
 1707              	.LVL100:
 1708              	.LBB51:
 1709              	.LBB52:
2148:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
2149:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
2150:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			usCount++;
2151:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
2152:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2153:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2154:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2155:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		return usCount;
2156:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
2157:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2158:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
2159:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
2160:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2161:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2162:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2163:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2164:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
2165:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	tskTCB *pxTCB;
2166:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned char *pcEndOfStack;
2167:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2168:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2169:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2170:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2171:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2172:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
2173:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2174:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
2175:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#else
2176:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		{
2177:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2178:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		}
2179:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		#endif
2180:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2181:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
2182:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2183:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		return uxReturn;
2184:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
2185:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2186:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #endif
2187:firmware/FreeRTOSV6.1.0/Source/tasks.c **** /*-----------------------------------------------------------*/
2188:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2189:firmware/FreeRTOSV6.1.0/Source/tasks.c **** #if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
2190:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 
2191:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2192:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
2193:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2194:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2195:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 1710              		.loc 1 2195 0
 1711 003a 206B     		ldr	r0, [r4, #48]
 1712 003c FFF7FEFF 		bl	vPortFree
2196:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vPortFree( pxTCB );
 1713              		.loc 1 2196 0
 1714 0040 2046     		mov	r0, r4
 1715 0042 FFF7FEFF 		bl	vPortFree
 1716              	.LVL101:
 1717              	.L131:
 1718              	.LBE52:
 1719              	.LBE51:
 1720              	.LBE50:
 1721              	.LBE49:
 1722              	.LBE48:
1841:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 1723              		.loc 1 1841 0
 1724 0046 064B     		ldr	r3, .L138+12
 1725 0048 1B68     		ldr	r3, [r3, #0]
 1726 004a 012B     		cmp	r3, #1
 1727 004c D9D9     		bls	.L137
1843:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				taskYIELD();
 1728              		.loc 1 1843 0
 1729 004e FFF7FEFF 		bl	vPortYieldFromISR
 1730 0052 D6E7     		b	.L137
 1731              	.L139:
 1732              		.align	2
 1733              	.L138:
 1734 0054 00000000 		.word	.LANCHOR15
 1735 0058 00000000 		.word	.LANCHOR7
 1736 005c 00000000 		.word	.LANCHOR1
 1737 0060 00000000 		.word	.LANCHOR3
 1738              		.cfi_endproc
 1739              	.LFE27:
 1741              		.section	.text.vTaskDelay,"ax",%progbits
 1742              		.align	1
 1743              		.global	vTaskDelay
 1744              		.thumb
 1745              		.thumb_func
 1747              	vTaskDelay:
 1748              	.LFB3:
 682:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 1749              		.loc 1 682 0
 1750              		.cfi_startproc
 1751              		@ args = 0, pretend = 0, frame = 0
 1752              		@ frame_needed = 0, uses_anonymous_args = 0
 1753              	.LVL102:
 1754 0000 70B5     		push	{r4, r5, r6, lr}
 1755              	.LCFI15:
 1756              		.cfi_def_cfa_offset 16
 687:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0 )
 1757              		.loc 1 687 0
 1758 0002 0446     		mov	r4, r0
 1759              		.cfi_offset 14, -4
 1760              		.cfi_offset 6, -8
 1761              		.cfi_offset 5, -12
 1762              		.cfi_offset 4, -16
 1763 0004 C0B1     		cbz	r0, .L141
 703:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 1764              		.loc 1 703 0
 1765 0006 0F4E     		ldr	r6, .L146
 689:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vTaskSuspendAll();
 1766              		.loc 1 689 0
 1767 0008 FFF7FEFF 		bl	vTaskSuspendAll
 1768              	.LVL103:
 703:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 1769              		.loc 1 703 0
 1770 000c 3568     		ldr	r5, [r6, #0]
 1771 000e 6519     		adds	r5, r4, r5
 1772              	.LVL104:
 708:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 1773              		.loc 1 708 0
 1774 0010 0D4C     		ldr	r4, .L146+4
 1775              	.LVL105:
 1776 0012 2068     		ldr	r0, [r4, #0]
 1777 0014 0430     		adds	r0, r0, #4
 1778 0016 FFF7FEFF 		bl	vListRemove
 711:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 1779              		.loc 1 711 0
 1780 001a 2368     		ldr	r3, [r4, #0]
 1781 001c 5D60     		str	r5, [r3, #4]
 713:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 1782              		.loc 1 713 0
 1783 001e 3368     		ldr	r3, [r6, #0]
 1784 0020 9D42     		cmp	r5, r3
 717:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 1785              		.loc 1 717 0
 1786 0022 34BF     		ite	cc
 1787 0024 094B     		ldrcc	r3, .L146+8
 723:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 1788              		.loc 1 723 0
 1789 0026 0A4B     		ldrcs	r3, .L146+12
 1790 0028 1868     		ldr	r0, [r3, #0]
 1791 002a 2168     		ldr	r1, [r4, #0]
 1792 002c 0431     		adds	r1, r1, #4
 1793 002e FFF7FEFF 		bl	vListInsert
 726:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 1794              		.loc 1 726 0
 1795 0032 FFF7FEFF 		bl	xTaskResumeAll
 1796              	.LVL106:
 731:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( !xAlreadyYielded )
 1797              		.loc 1 731 0
 1798 0036 18B9     		cbnz	r0, .L140
 1799              	.LVL107:
 1800              	.L141:
 735:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 1801              		.loc 1 735 0
 1802 0038 BDE87040 		pop	{r4, r5, r6, lr}
 733:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			portYIELD_WITHIN_API();
 1803              		.loc 1 733 0
 1804 003c FFF7FEBF 		b	vPortYieldFromISR
 1805              	.LVL108:
 1806              	.L140:
 1807 0040 70BD     		pop	{r4, r5, r6, pc}
 1808              	.L147:
 1809 0042 00BF     		.align	2
 1810              	.L146:
 1811 0044 00000000 		.word	.LANCHOR17
 1812 0048 00000000 		.word	.LANCHOR2
 1813 004c 00000000 		.word	.LANCHOR10
 1814 0050 00000000 		.word	.LANCHOR9
 1815              		.cfi_endproc
 1816              	.LFE3:
 1818              		.section	.text.vTaskDelayUntil,"ax",%progbits
 1819              		.align	1
 1820              		.global	vTaskDelayUntil
 1821              		.thumb
 1822              		.thumb_func
 1824              	vTaskDelayUntil:
 1825              	.LFB2:
 605:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 1826              		.loc 1 605 0
 1827              		.cfi_startproc
 1828              		@ args = 0, pretend = 0, frame = 0
 1829              		@ frame_needed = 0, uses_anonymous_args = 0
 1830              	.LVL109:
 1831 0000 70B5     		push	{r4, r5, r6, lr}
 1832              	.LCFI16:
 1833              		.cfi_def_cfa_offset 16
 614:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 1834              		.loc 1 614 0
 1835 0002 194E     		ldr	r6, .L158
 1836              		.cfi_offset 14, -4
 1837              		.cfi_offset 6, -8
 1838              		.cfi_offset 5, -12
 1839              		.cfi_offset 4, -16
 605:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 1840              		.loc 1 605 0
 1841 0004 0546     		mov	r5, r0
 1842 0006 0C46     		mov	r4, r1
 609:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vTaskSuspendAll();
 1843              		.loc 1 609 0
 1844 0008 FFF7FEFF 		bl	vTaskSuspendAll
 1845              	.LVL110:
 612:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1846              		.loc 1 612 0
 1847 000c 2B68     		ldr	r3, [r5, #0]
 614:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 1848              		.loc 1 614 0
 1849 000e 3268     		ldr	r2, [r6, #0]
 612:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1850              		.loc 1 612 0
 1851 0010 E418     		adds	r4, r4, r3
 1852              	.LVL111:
 614:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 1853              		.loc 1 614 0
 1854 0012 9A42     		cmp	r2, r3
 1855 0014 02D2     		bcs	.L149
 621:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 1856              		.loc 1 621 0
 1857 0016 9C42     		cmp	r4, r3
 1858 0018 08D2     		bcs	.L154
 1859 001a 01E0     		b	.L156
 1860              	.L149:
 631:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 1861              		.loc 1 631 0
 1862 001c 9C42     		cmp	r4, r3
 1863 001e 07D3     		bcc	.L155
 1864              	.L156:
 631:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 1865              		.loc 1 631 0 is_stmt 0 discriminator 1
 1866 0020 3368     		ldr	r3, [r6, #0]
 607:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 1867              		.loc 1 607 0 is_stmt 1 discriminator 1
 1868 0022 9C42     		cmp	r4, r3
 1869 0024 94BF     		ite	ls
 1870 0026 0023     		movls	r3, #0
 1871 0028 0123     		movhi	r3, #1
 1872 002a 02E0     		b	.L150
 1873              	.L154:
 607:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 1874              		.loc 1 607 0 is_stmt 0
 1875 002c 0023     		movs	r3, #0
 1876 002e 00E0     		b	.L150
 1877              	.L155:
 633:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 1878              		.loc 1 633 0 is_stmt 1
 1879 0030 0123     		movs	r3, #1
 1880              	.L150:
 1881              	.LVL112:
 638:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 1882              		.loc 1 638 0
 1883 0032 2C60     		str	r4, [r5, #0]
 640:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( xShouldDelay )
 1884              		.loc 1 640 0
 1885 0034 83B1     		cbz	r3, .L151
 647:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 1886              		.loc 1 647 0
 1887 0036 0D4D     		ldr	r5, .L158+4
 1888              	.LVL113:
 1889 0038 2868     		ldr	r0, [r5, #0]
 1890 003a 0430     		adds	r0, r0, #4
 1891 003c FFF7FEFF 		bl	vListRemove
 1892              	.LVL114:
 650:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 1893              		.loc 1 650 0
 1894 0040 2B68     		ldr	r3, [r5, #0]
 1895 0042 5C60     		str	r4, [r3, #4]
 652:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( xTimeToWake < xTickCount )
 1896              		.loc 1 652 0
 1897 0044 3368     		ldr	r3, [r6, #0]
 1898 0046 9C42     		cmp	r4, r3
 656:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 1899              		.loc 1 656 0
 1900 0048 34BF     		ite	cc
 1901 004a 094B     		ldrcc	r3, .L158+8
 662:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 1902              		.loc 1 662 0
 1903 004c 094B     		ldrcs	r3, .L158+12
 1904 004e 1868     		ldr	r0, [r3, #0]
 1905 0050 2968     		ldr	r1, [r5, #0]
 1906 0052 0431     		adds	r1, r1, #4
 1907 0054 FFF7FEFF 		bl	vListInsert
 1908              	.L151:
 666:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 1909              		.loc 1 666 0
 1910 0058 FFF7FEFF 		bl	xTaskResumeAll
 1911              	.LVL115:
 670:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( !xAlreadyYielded )
 1912              		.loc 1 670 0
 1913 005c 18B9     		cbnz	r0, .L148
 674:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 1914              		.loc 1 674 0
 1915 005e BDE87040 		pop	{r4, r5, r6, lr}
 672:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			portYIELD_WITHIN_API();
 1916              		.loc 1 672 0
 1917 0062 FFF7FEBF 		b	vPortYieldFromISR
 1918              	.LVL116:
 1919              	.L148:
 1920 0066 70BD     		pop	{r4, r5, r6, pc}
 1921              	.L159:
 1922              		.align	2
 1923              	.L158:
 1924 0068 00000000 		.word	.LANCHOR17
 1925 006c 00000000 		.word	.LANCHOR2
 1926 0070 00000000 		.word	.LANCHOR10
 1927 0074 00000000 		.word	.LANCHOR9
 1928              		.cfi_endproc
 1929              	.LFE2:
 1931              		.section	.text.vTaskSwitchContext,"ax",%progbits
 1932              		.align	1
 1933              		.global	vTaskSwitchContext
 1934              		.thumb
 1935              		.thumb_func
 1937              	vTaskSwitchContext:
 1938              	.LFB21:
1584:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 1939              		.loc 1 1584 0
 1940              		.cfi_startproc
 1941              		@ args = 0, pretend = 0, frame = 0
 1942              		@ frame_needed = 0, uses_anonymous_args = 0
1585:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 1943              		.loc 1 1585 0
 1944 0000 234B     		ldr	r3, .L167
1584:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 1945              		.loc 1 1584 0
 1946 0002 30B5     		push	{r4, r5, lr}
 1947              	.LCFI17:
 1948              		.cfi_def_cfa_offset 12
1585:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 1949              		.loc 1 1585 0
 1950 0004 1B68     		ldr	r3, [r3, #0]
 1951 0006 2BB1     		cbz	r3, .L161
 1952              		.cfi_offset 14, -4
 1953              		.cfi_offset 5, -8
 1954              		.cfi_offset 4, -12
1589:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xMissedYield = pdTRUE;
 1955              		.loc 1 1589 0
 1956 0008 0122     		movs	r2, #1
 1957 000a 224B     		ldr	r3, .L167+4
 1958 000c 3BE0     		b	.L166
 1959              	.L163:
1615:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		--uxTopReadyPriority;
 1960              		.loc 1 1615 0
 1961 000e 1A68     		ldr	r2, [r3, #0]
 1962 0010 013A     		subs	r2, r2, #1
 1963 0012 1A60     		str	r2, [r3, #0]
 1964              	.L161:
1613:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 1965              		.loc 1 1613 0 discriminator 1
 1966 0014 204B     		ldr	r3, .L167+8
 1967 0016 1424     		movs	r4, #20
 1968 0018 1968     		ldr	r1, [r3, #0]
 1969 001a 204A     		ldr	r2, .L167+12
 1970 001c 6143     		muls	r1, r4, r1
 1971 001e 5158     		ldr	r1, [r2, r1]
 1972 0020 0029     		cmp	r1, #0
 1973 0022 F4D0     		beq	.L163
 1974              	.LBB53:
1620:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 1975              		.loc 1 1620 0
 1976 0024 1868     		ldr	r0, [r3, #0]
 1977              	.LVL117:
 1978 0026 4443     		muls	r4, r0, r4
 1979 0028 1319     		adds	r3, r2, r4
 1980 002a 5968     		ldr	r1, [r3, #4]
 1981 002c 0834     		adds	r4, r4, #8
 1982 002e 4968     		ldr	r1, [r1, #4]
 1983 0030 1419     		adds	r4, r2, r4
 1984 0032 5960     		str	r1, [r3, #4]
 1985 0034 A142     		cmp	r1, r4
 1986 0036 04BF     		itt	eq
 1987 0038 4968     		ldreq	r1, [r1, #4]
 1988 003a 5960     		streq	r1, [r3, #4]
 1989 003c 1423     		movs	r3, #20
 1990 003e 03FB0022 		mla	r2, r3, r0, r2
 1991 0042 5368     		ldr	r3, [r2, #4]
 1992              	.LBE53:
1623:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vWriteTraceToBuffer();
 1993              		.loc 1 1623 0
 1994 0044 1649     		ldr	r1, .L167+16
 1995              	.LBB54:
1620:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 1996              		.loc 1 1620 0
 1997 0046 DB68     		ldr	r3, [r3, #12]
 1998 0048 164A     		ldr	r2, .L167+20
 1999 004a 1360     		str	r3, [r2, #0]
 2000              	.LBE54:
1623:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vWriteTraceToBuffer();
 2001              		.loc 1 1623 0
 2002 004c 0B68     		ldr	r3, [r1, #0]
 2003 004e F3B1     		cbz	r3, .L160
1623:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vWriteTraceToBuffer();
 2004              		.loc 1 1623 0 is_stmt 0 discriminator 1
 2005 0050 1368     		ldr	r3, [r2, #0]
 2006 0052 1548     		ldr	r0, .L167+24
 2007              	.LVL118:
 2008 0054 5B6C     		ldr	r3, [r3, #68]
 2009 0056 0468     		ldr	r4, [r0, #0]
 2010 0058 9C42     		cmp	r4, r3
 2011 005a 18D0     		beq	.L160
1623:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vWriteTraceToBuffer();
 2012              		.loc 1 1623 0 discriminator 2
 2013 005c 134B     		ldr	r3, .L167+28
 2014 005e 144D     		ldr	r5, .L167+32
 2015 0060 1C68     		ldr	r4, [r3, #0]
 2016 0062 2D68     		ldr	r5, [r5, #0]
 2017 0064 0834     		adds	r4, r4, #8
 2018 0066 A542     		cmp	r5, r4
 2019 0068 0FD9     		bls	.L165
1623:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vWriteTraceToBuffer();
 2020              		.loc 1 1623 0 discriminator 3
 2021 006a 1268     		ldr	r2, [r2, #0]
 2022 006c 1968     		ldr	r1, [r3, #0]
 2023 006e 526C     		ldr	r2, [r2, #68]
 2024 0070 0260     		str	r2, [r0, #0]
 2025 0072 1048     		ldr	r0, .L167+36
 2026 0074 0068     		ldr	r0, [r0, #0]
 2027 0076 0860     		str	r0, [r1, #0]
 2028 0078 1968     		ldr	r1, [r3, #0]
 2029 007a 0431     		adds	r1, r1, #4
 2030 007c 1960     		str	r1, [r3, #0]
 2031 007e 1968     		ldr	r1, [r3, #0]
 2032 0080 0A60     		str	r2, [r1, #0]
 2033 0082 1A68     		ldr	r2, [r3, #0]
 2034 0084 0432     		adds	r2, r2, #4
 2035              	.L166:
 2036 0086 1A60     		str	r2, [r3, #0]
 2037 0088 30BD     		pop	{r4, r5, pc}
 2038              	.L165:
1623:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vWriteTraceToBuffer();
 2039              		.loc 1 1623 0 discriminator 4
 2040 008a 0023     		movs	r3, #0
 2041 008c 0B60     		str	r3, [r1, #0]
 2042              	.L160:
 2043 008e 30BD     		pop	{r4, r5, pc}
 2044              	.L168:
 2045              		.align	2
 2046              	.L167:
 2047 0090 00000000 		.word	.LANCHOR16
 2048 0094 00000000 		.word	.LANCHOR24
 2049 0098 00000000 		.word	.LANCHOR14
 2050 009c 00000000 		.word	.LANCHOR3
 2051 00a0 00000000 		.word	.LANCHOR21
 2052 00a4 00000000 		.word	.LANCHOR2
 2053 00a8 00000000 		.word	.LANCHOR25
 2054 00ac 00000000 		.word	.LANCHOR18
 2055 00b0 00000000 		.word	.LANCHOR20
 2056 00b4 00000000 		.word	.LANCHOR17
 2057              		.cfi_endproc
 2058              	.LFE21:
 2060              		.section	.text.vTaskSuspend,"ax",%progbits
 2061              		.align	1
 2062              		.global	vTaskSuspend
 2063              		.thumb
 2064              		.thumb_func
 2066              	vTaskSuspend:
 2067              	.LFB6:
 870:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 2068              		.loc 1 870 0 is_stmt 1
 2069              		.cfi_startproc
 2070              		@ args = 0, pretend = 0, frame = 0
 2071              		@ frame_needed = 0, uses_anonymous_args = 0
 2072              	.LVL119:
 2073 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 2074              	.LCFI18:
 2075              		.cfi_def_cfa_offset 24
 877:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 2076              		.loc 1 877 0
 2077 0004 184D     		ldr	r5, .L177
 2078              		.cfi_offset 14, -4
 2079              		.cfi_offset 8, -8
 2080              		.cfi_offset 7, -12
 2081              		.cfi_offset 6, -16
 2082              		.cfi_offset 5, -20
 2083              		.cfi_offset 4, -24
 870:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	{
 2084              		.loc 1 870 0
 2085 0006 0446     		mov	r4, r0
 873:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portENTER_CRITICAL();
 2086              		.loc 1 873 0
 2087 0008 FFF7FEFF 		bl	vPortEnterCritical
 2088              	.LVL120:
 877:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 2089              		.loc 1 877 0
 2090 000c 2B68     		ldr	r3, [r5, #0]
 2091 000e 9C42     		cmp	r4, r3
 2092 0010 00D0     		beq	.L170
 883:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 2093              		.loc 1 883 0
 2094 0012 14B9     		cbnz	r4, .L171
 2095              	.L170:
 883:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 2096              		.loc 1 883 0 is_stmt 0 discriminator 1
 2097 0014 2E68     		ldr	r6, [r5, #0]
 2098 0016 0024     		movs	r4, #0
 2099              	.LVL121:
 2100 0018 00E0     		b	.L172
 2101              	.LVL122:
 2102              	.L171:
 883:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 2103              		.loc 1 883 0 discriminator 2
 2104 001a 2646     		mov	r6, r4
 2105              	.LVL123:
 2106              	.L172:
 888:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 2107              		.loc 1 888 0 is_stmt 1 discriminator 3
 2108 001c 371D     		adds	r7, r6, #4
 2109 001e 3846     		mov	r0, r7
 2110 0020 FFF7FEFF 		bl	vListRemove
 891:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 2111              		.loc 1 891 0 discriminator 3
 2112 0024 B36A     		ldr	r3, [r6, #40]
 2113 0026 1BB1     		cbz	r3, .L173
 893:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 2114              		.loc 1 893 0
 2115 0028 06F11800 		add	r0, r6, #24
 2116 002c FFF7FEFF 		bl	vListRemove
 2117              	.L173:
 896:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 2118              		.loc 1 896 0
 2119 0030 0E48     		ldr	r0, .L177+4
 2120 0032 3946     		mov	r1, r7
 2121 0034 FFF7FEFF 		bl	vListInsertEnd
 898:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		portEXIT_CRITICAL();
 2122              		.loc 1 898 0
 2123 0038 FFF7FEFF 		bl	vPortExitCritical
 900:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 2124              		.loc 1 900 0
 2125 003c 002C     		cmp	r4, #0
 2126 003e 11D1     		bne	.L169
 902:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 2127              		.loc 1 902 0
 2128 0040 0B4B     		ldr	r3, .L177+8
 2129 0042 1B68     		ldr	r3, [r3, #0]
 2130 0044 1BB1     		cbz	r3, .L175
 926:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 2131              		.loc 1 926 0
 2132 0046 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 905:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				portYIELD_WITHIN_API();
 2133              		.loc 1 905 0
 2134 004a FFF7FEBF 		b	vPortYieldFromISR
 2135              	.L175:
 912:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == 1 )
 2136              		.loc 1 912 0
 2137 004e 094B     		ldr	r3, .L177+12
 2138 0050 1B68     		ldr	r3, [r3, #0]
 2139 0052 012B     		cmp	r3, #1
 2140 0054 02D1     		bne	.L176
 918:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					pxCurrentTCB = NULL;
 2141              		.loc 1 918 0
 2142 0056 2C60     		str	r4, [r5, #0]
 2143 0058 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2144              	.L176:
 926:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	}
 2145              		.loc 1 926 0
 2146 005c BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 922:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 					vTaskSwitchContext();
 2147              		.loc 1 922 0
 2148 0060 FFF7FEBF 		b	vTaskSwitchContext
 2149              	.L169:
 2150 0064 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2151              	.L178:
 2152              		.align	2
 2153              	.L177:
 2154 0068 00000000 		.word	.LANCHOR2
 2155 006c 00000000 		.word	.LANCHOR8
 2156 0070 00000000 		.word	.LANCHOR11
 2157 0074 00000000 		.word	.LANCHOR1
 2158              		.cfi_endproc
 2159              	.LFE6:
 2161              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2162              		.align	1
 2163              		.global	vTaskPlaceOnEventList
 2164              		.thumb
 2165              		.thumb_func
 2167              	vTaskPlaceOnEventList:
 2168              	.LFB22:
1628:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 2169              		.loc 1 1628 0
 2170              		.cfi_startproc
 2171              		@ args = 0, pretend = 0, frame = 0
 2172              		@ frame_needed = 0, uses_anonymous_args = 0
 2173              	.LVL124:
 2174 0000 70B5     		push	{r4, r5, r6, lr}
 2175              	.LCFI19:
 2176              		.cfi_def_cfa_offset 16
1637:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2177              		.loc 1 1637 0
 2178 0002 124C     		ldr	r4, .L183
 2179              		.cfi_offset 14, -4
 2180              		.cfi_offset 6, -8
 2181              		.cfi_offset 5, -12
 2182              		.cfi_offset 4, -16
1628:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 2183              		.loc 1 1628 0
 2184 0004 0D46     		mov	r5, r1
1637:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2185              		.loc 1 1637 0
 2186 0006 2168     		ldr	r1, [r4, #0]
 2187              	.LVL125:
 2188 0008 1831     		adds	r1, r1, #24
 2189 000a FFF7FEFF 		bl	vListInsert
 2190              	.LVL126:
1642:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2191              		.loc 1 1642 0
 2192 000e 2068     		ldr	r0, [r4, #0]
 2193 0010 0430     		adds	r0, r0, #4
 2194 0012 FFF7FEFF 		bl	vListRemove
1647:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2195              		.loc 1 1647 0
 2196 0016 B5F1FF3F 		cmp	r5, #-1
 2197 001a 06D1     		bne	.L180
1652:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2198              		.loc 1 1652 0
 2199 001c 2168     		ldr	r1, [r4, #0]
 2200 001e 0C48     		ldr	r0, .L183+4
 2201 0020 0431     		adds	r1, r1, #4
1694:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 2202              		.loc 1 1694 0
 2203 0022 BDE87040 		pop	{r4, r5, r6, lr}
1652:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2204              		.loc 1 1652 0
 2205 0026 FFF7FEBF 		b	vListInsertEnd
 2206              	.L180:
1658:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2207              		.loc 1 1658 0
 2208 002a 0A4B     		ldr	r3, .L183+8
 2209 002c 1A68     		ldr	r2, [r3, #0]
 2210 002e AD18     		adds	r5, r5, r2
 2211              	.LVL127:
1660:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2212              		.loc 1 1660 0
 2213 0030 2268     		ldr	r2, [r4, #0]
1662:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
 2214              		.loc 1 1662 0
 2215 0032 1B68     		ldr	r3, [r3, #0]
1660:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 2216              		.loc 1 1660 0
 2217 0034 5560     		str	r5, [r2, #4]
1662:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( xTimeToWake < xTickCount )
 2218              		.loc 1 1662 0
 2219 0036 9D42     		cmp	r5, r3
1665:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
 2220              		.loc 1 1665 0
 2221 0038 34BF     		ite	cc
 2222 003a 074B     		ldrcc	r3, .L183+12
1670:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
 2223              		.loc 1 1670 0
 2224 003c 074B     		ldrcs	r3, .L183+16
 2225 003e 1868     		ldr	r0, [r3, #0]
 2226 0040 2168     		ldr	r1, [r4, #0]
 2227 0042 0431     		adds	r1, r1, #4
1694:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 2228              		.loc 1 1694 0
 2229 0044 BDE87040 		pop	{r4, r5, r6, lr}
1670:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
 2230              		.loc 1 1670 0
 2231 0048 FFF7FEBF 		b	vListInsert
 2232              	.L184:
 2233              		.align	2
 2234              	.L183:
 2235 004c 00000000 		.word	.LANCHOR2
 2236 0050 00000000 		.word	.LANCHOR8
 2237 0054 00000000 		.word	.LANCHOR17
 2238 0058 00000000 		.word	.LANCHOR10
 2239 005c 00000000 		.word	.LANCHOR9
 2240              		.cfi_endproc
 2241              	.LFE22:
 2243              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2244              		.align	1
 2245              		.global	xTaskRemoveFromEventList
 2246              		.thumb
 2247              		.thumb_func
 2249              	xTaskRemoveFromEventList:
 2250              	.LFB23:
1698:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 2251              		.loc 1 1698 0
 2252              		.cfi_startproc
 2253              		@ args = 0, pretend = 0, frame = 0
 2254              		@ frame_needed = 0, uses_anonymous_args = 0
 2255              	.LVL128:
 2256 0000 38B5     		push	{r3, r4, r5, lr}
 2257              	.LCFI20:
 2258              		.cfi_def_cfa_offset 16
1712:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2259              		.loc 1 1712 0
 2260 0002 0468     		ldr	r4, [r0, #0]
 2261              		.cfi_offset 14, -4
 2262              		.cfi_offset 5, -8
 2263              		.cfi_offset 4, -12
 2264              		.cfi_offset 3, -16
 2265 0004 0CB1     		cbz	r4, .L186
1712:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2266              		.loc 1 1712 0 is_stmt 0 discriminator 1
 2267 0006 C368     		ldr	r3, [r0, #12]
 2268 0008 DC68     		ldr	r4, [r3, #12]
 2269              	.L186:
 2270              	.LVL129:
1713:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2271              		.loc 1 1713 0 is_stmt 1 discriminator 3
 2272 000a 04F11805 		add	r5, r4, #24
 2273 000e 2846     		mov	r0, r5
 2274              	.LVL130:
 2275 0010 FFF7FEFF 		bl	vListRemove
1715:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2276              		.loc 1 1715 0 discriminator 3
 2277 0014 0F4B     		ldr	r3, .L192
 2278 0016 1B68     		ldr	r3, [r3, #0]
 2279 0018 73B9     		cbnz	r3, .L187
1717:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2280              		.loc 1 1717 0
 2281 001a 251D     		adds	r5, r4, #4
 2282 001c 2846     		mov	r0, r5
 2283 001e FFF7FEFF 		bl	vListRemove
1718:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2284              		.loc 1 1718 0
 2285 0022 0D4A     		ldr	r2, .L192+4
 2286 0024 E36A     		ldr	r3, [r4, #44]
 2287 0026 1168     		ldr	r1, [r2, #0]
 2288 0028 8B42     		cmp	r3, r1
 2289 002a 88BF     		it	hi
 2290 002c 1360     		strhi	r3, [r2, #0]
 2291 002e 0B4A     		ldr	r2, .L192+8
 2292 0030 1420     		movs	r0, #20
 2293 0032 00FB0320 		mla	r0, r0, r3, r2
 2294 0036 00E0     		b	.L191
 2295              	.L187:
1724:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2296              		.loc 1 1724 0
 2297 0038 0948     		ldr	r0, .L192+12
 2298              	.L191:
 2299 003a 2946     		mov	r1, r5
 2300 003c FFF7FEFF 		bl	vListInsertEnd
1727:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2301              		.loc 1 1727 0
 2302 0040 084B     		ldr	r3, .L192+16
1733:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xReturn = pdTRUE;
 2303              		.loc 1 1733 0
 2304 0042 E06A     		ldr	r0, [r4, #44]
1727:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2305              		.loc 1 1727 0
 2306 0044 1B68     		ldr	r3, [r3, #0]
 2307              	.LVL131:
1733:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		xReturn = pdTRUE;
 2308              		.loc 1 1733 0
 2309 0046 DB6A     		ldr	r3, [r3, #44]
 2310              	.LVL132:
1741:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 2311              		.loc 1 1741 0
 2312 0048 9842     		cmp	r0, r3
 2313 004a 34BF     		ite	cc
 2314 004c 0020     		movcc	r0, #0
 2315 004e 0120     		movcs	r0, #1
 2316 0050 38BD     		pop	{r3, r4, r5, pc}
 2317              	.L193:
 2318 0052 00BF     		.align	2
 2319              	.L192:
 2320 0054 00000000 		.word	.LANCHOR16
 2321 0058 00000000 		.word	.LANCHOR14
 2322 005c 00000000 		.word	.LANCHOR3
 2323 0060 00000000 		.word	.LANCHOR6
 2324 0064 00000000 		.word	.LANCHOR2
 2325              		.cfi_endproc
 2326              	.LFE23:
 2328              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2329              		.align	1
 2330              		.global	vTaskSetTimeOutState
 2331              		.thumb
 2332              		.thumb_func
 2334              	vTaskSetTimeOutState:
 2335              	.LFB24:
1745:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 2336              		.loc 1 1745 0
 2337              		.cfi_startproc
 2338              		@ args = 0, pretend = 0, frame = 0
 2339              		@ frame_needed = 0, uses_anonymous_args = 0
 2340              		@ link register save eliminated.
 2341              	.LVL133:
1746:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2342              		.loc 1 1746 0
 2343 0000 034B     		ldr	r3, .L195
 2344 0002 1B68     		ldr	r3, [r3, #0]
 2345 0004 0360     		str	r3, [r0, #0]
1747:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2346              		.loc 1 1747 0
 2347 0006 034B     		ldr	r3, .L195+4
 2348 0008 1B68     		ldr	r3, [r3, #0]
 2349 000a 4360     		str	r3, [r0, #4]
1748:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 2350              		.loc 1 1748 0
 2351 000c 7047     		bx	lr
 2352              	.L196:
 2353 000e 00BF     		.align	2
 2354              	.L195:
 2355 0010 00000000 		.word	.LANCHOR22
 2356 0014 00000000 		.word	.LANCHOR17
 2357              		.cfi_endproc
 2358              	.LFE24:
 2360              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2361              		.align	1
 2362              		.global	xTaskCheckForTimeOut
 2363              		.thumb
 2364              		.thumb_func
 2366              	xTaskCheckForTimeOut:
 2367              	.LFB25:
1752:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 2368              		.loc 1 1752 0
 2369              		.cfi_startproc
 2370              		@ args = 0, pretend = 0, frame = 0
 2371              		@ frame_needed = 0, uses_anonymous_args = 0
 2372              	.LVL134:
 2373 0000 38B5     		push	{r3, r4, r5, lr}
 2374              	.LCFI21:
 2375              		.cfi_def_cfa_offset 16
1752:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 2376              		.loc 1 1752 0
 2377 0002 0D46     		mov	r5, r1
 2378              		.cfi_offset 14, -4
 2379              		.cfi_offset 5, -8
 2380              		.cfi_offset 4, -12
 2381              		.cfi_offset 3, -16
 2382 0004 0446     		mov	r4, r0
1755:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portENTER_CRITICAL();
 2383              		.loc 1 1755 0
 2384 0006 FFF7FEFF 		bl	vPortEnterCritical
 2385              	.LVL135:
1761:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2386              		.loc 1 1761 0
 2387 000a 2B68     		ldr	r3, [r5, #0]
 2388 000c B3F1FF3F 		cmp	r3, #-1
 2389 0010 16D0     		beq	.L200
1768:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2390              		.loc 1 1768 0
 2391 0012 0F4A     		ldr	r2, .L203
 2392 0014 1168     		ldr	r1, [r2, #0]
 2393 0016 2268     		ldr	r2, [r4, #0]
 2394 0018 9142     		cmp	r1, r2
 2395 001a 0E4A     		ldr	r2, .L203+4
 2396 001c 03D0     		beq	.L199
1768:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2397              		.loc 1 1768 0 is_stmt 0 discriminator 1
 2398 001e 1068     		ldr	r0, [r2, #0]
 2399 0020 6168     		ldr	r1, [r4, #4]
 2400 0022 8842     		cmp	r0, r1
 2401 0024 0ED2     		bcs	.L202
 2402              	.L199:
1776:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2403              		.loc 1 1776 0 is_stmt 1
 2404 0026 1168     		ldr	r1, [r2, #0]
 2405 0028 6268     		ldr	r2, [r4, #4]
 2406 002a 891A     		subs	r1, r1, r2
 2407 002c 9942     		cmp	r1, r3
 2408 002e 09D2     		bcs	.L202
1779:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2409              		.loc 1 1779 0
 2410 0030 0849     		ldr	r1, .L203+4
1780:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2411              		.loc 1 1780 0
 2412 0032 2046     		mov	r0, r4
1779:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2413              		.loc 1 1779 0
 2414 0034 0968     		ldr	r1, [r1, #0]
 2415 0036 521A     		subs	r2, r2, r1
 2416 0038 D318     		adds	r3, r2, r3
 2417 003a 2B60     		str	r3, [r5, #0]
1780:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2418              		.loc 1 1780 0
 2419 003c FFF7FEFF 		bl	vTaskSetTimeOutState
 2420              	.LVL136:
 2421              	.L200:
1763:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 				xReturn = pdFALSE;
 2422              		.loc 1 1763 0
 2423 0040 0024     		movs	r4, #0
 2424              	.LVL137:
 2425 0042 00E0     		b	.L198
 2426              	.LVL138:
 2427              	.L202:
1785:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 			xReturn = pdTRUE;
 2428              		.loc 1 1785 0
 2429 0044 0124     		movs	r4, #1
 2430              	.LVL139:
 2431              	.L198:
1788:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	portEXIT_CRITICAL();
 2432              		.loc 1 1788 0
 2433 0046 FFF7FEFF 		bl	vPortExitCritical
1791:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 2434              		.loc 1 1791 0
 2435 004a 2046     		mov	r0, r4
 2436 004c 38BD     		pop	{r3, r4, r5, pc}
 2437              	.L204:
 2438 004e 00BF     		.align	2
 2439              	.L203:
 2440 0050 00000000 		.word	.LANCHOR22
 2441 0054 00000000 		.word	.LANCHOR17
 2442              		.cfi_endproc
 2443              	.LFE25:
 2445              		.section	.text.vTaskMissedYield,"ax",%progbits
 2446              		.align	1
 2447              		.global	vTaskMissedYield
 2448              		.thumb
 2449              		.thumb_func
 2451              	vTaskMissedYield:
 2452              	.LFB26:
1795:firmware/FreeRTOSV6.1.0/Source/tasks.c **** {
 2453              		.loc 1 1795 0
 2454              		.cfi_startproc
 2455              		@ args = 0, pretend = 0, frame = 0
 2456              		@ frame_needed = 0, uses_anonymous_args = 0
 2457              		@ link register save eliminated.
1796:firmware/FreeRTOSV6.1.0/Source/tasks.c **** 	xMissedYield = pdTRUE;
 2458              		.loc 1 1796 0
 2459 0000 014B     		ldr	r3, .L206
 2460 0002 0122     		movs	r2, #1
 2461 0004 1A60     		str	r2, [r3, #0]
1797:firmware/FreeRTOSV6.1.0/Source/tasks.c **** }
 2462              		.loc 1 1797 0
 2463 0006 7047     		bx	lr
 2464              	.L207:
 2465              		.align	2
 2466              	.L206:
 2467 0008 00000000 		.word	.LANCHOR24
 2468              		.cfi_endproc
 2469              	.LFE26:
 2471              		.global	pxCurrentTCB
 2472              		.section	.bss.xPendingReadyList,"aw",%nobits
 2473              		.align	2
 2474              		.set	.LANCHOR6,. + 0
 2477              	xPendingReadyList:
 2478 0000 00000000 		.space	20
 2478      00000000 
 2478      00000000 
 2478      00000000 
 2478      00000000 
 2479              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 2480              		.align	2
 2481              		.set	.LANCHOR14,. + 0
 2484              	uxTopReadyPriority:
 2485 0000 00000000 		.space	4
 2486              		.section	.bss.uxTasksDeleted,"aw",%nobits
 2487              		.align	2
 2488              		.set	.LANCHOR15,. + 0
 2491              	uxTasksDeleted:
 2492 0000 00000000 		.space	4
 2493              		.section	.bss.xTickCount,"aw",%nobits
 2494              		.align	2
 2495              		.set	.LANCHOR17,. + 0
 2498              	xTickCount:
 2499 0000 00000000 		.space	4
 2500              		.section	.bss.pxReadyTasksLists,"aw",%nobits
 2501              		.align	2
 2502              		.set	.LANCHOR3,. + 0
 2505              	pxReadyTasksLists:
 2506 0000 00000000 		.space	100
 2506      00000000 
 2506      00000000 
 2506      00000000 
 2506      00000000 
 2507              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
 2508              		.align	2
 2509              		.set	.LANCHOR10,. + 0
 2512              	pxOverflowDelayedTaskList:
 2513 0000 00000000 		.space	4
 2514              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
 2515              		.align	2
 2516              		.set	.LANCHOR7,. + 0
 2519              	xTasksWaitingTermination:
 2520 0000 00000000 		.space	20
 2520      00000000 
 2520      00000000 
 2520      00000000 
 2520      00000000 
 2521              		.section	.bss.xTracing,"aw",%nobits
 2522              		.align	2
 2523              		.set	.LANCHOR21,. + 0
 2526              	xTracing:
 2527 0000 00000000 		.space	4
 2528              		.section	.bss.pxDelayedTaskList,"aw",%nobits
 2529              		.align	2
 2530              		.set	.LANCHOR9,. + 0
 2533              	pxDelayedTaskList:
 2534 0000 00000000 		.space	4
 2535              		.section	.bss.xSchedulerRunning,"aw",%nobits
 2536              		.align	2
 2537              		.set	.LANCHOR11,. + 0
 2540              	xSchedulerRunning:
 2541 0000 00000000 		.space	4
 2542              		.section	.bss.xMissedYield,"aw",%nobits
 2543              		.align	2
 2544              		.set	.LANCHOR24,. + 0
 2547              	xMissedYield:
 2548 0000 00000000 		.space	4
 2549              		.section	.rodata.str1.1,"aMS",%progbits,1
 2550              	.LC0:
 2551 0000 25730909 		.ascii	"%s\011\011%c\011%u\011%u\011%u\015\012\000"
 2551      25630925 
 2551      75092575 
 2551      0925750D 
 2551      0A00
 2552              	.LC1:
 2553 0012 49444C45 		.ascii	"IDLE\000"
 2553      00
 2554              	.LC2:
 2555 0017 0D0A00   		.ascii	"\015\012\000"
 2556              		.section	.bss.pcTraceBuffer,"aw",%nobits
 2557              		.align	2
 2558              		.set	.LANCHOR18,. + 0
 2561              	pcTraceBuffer:
 2562 0000 00000000 		.space	4
 2563              		.section	.bss.pxCurrentTCB,"aw",%nobits
 2564              		.align	2
 2565              		.set	.LANCHOR2,. + 0
 2568              	pxCurrentTCB:
 2569 0000 00000000 		.space	4
 2570              		.section	.bss.pcStatusString,"aw",%nobits
 2571              		.set	.LANCHOR0,. + 0
 2574              	pcStatusString:
 2575 0000 00000000 		.space	50
 2575      00000000 
 2575      00000000 
 2575      00000000 
 2575      00000000 
 2576              		.section	.data.uxPreviousTask,"aw",%progbits
 2577              		.align	2
 2578              		.set	.LANCHOR25,. + 0
 2581              	uxPreviousTask:
 2582 0000 FF000000 		.word	255
 2583              		.section	.bss.xSuspendedTaskList,"aw",%nobits
 2584              		.align	2
 2585              		.set	.LANCHOR8,. + 0
 2588              	xSuspendedTaskList:
 2589 0000 00000000 		.space	20
 2589      00000000 
 2589      00000000 
 2589      00000000 
 2589      00000000 
 2590              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
 2591              		.align	2
 2592              		.set	.LANCHOR1,. + 0
 2595              	uxCurrentNumberOfTasks:
 2596 0000 00000000 		.space	4
 2597              		.section	.bss.xDelayedTaskList1,"aw",%nobits
 2598              		.align	2
 2599              		.set	.LANCHOR4,. + 0
 2602              	xDelayedTaskList1:
 2603 0000 00000000 		.space	20
 2603      00000000 
 2603      00000000 
 2603      00000000 
 2603      00000000 
 2604              		.section	.bss.xDelayedTaskList2,"aw",%nobits
 2605              		.align	2
 2606              		.set	.LANCHOR5,. + 0
 2609              	xDelayedTaskList2:
 2610 0000 00000000 		.space	20
 2610      00000000 
 2610      00000000 
 2610      00000000 
 2610      00000000 
 2611              		.section	.bss.uxTaskNumber,"aw",%nobits
 2612              		.align	2
 2613              		.set	.LANCHOR13,. + 0
 2616              	uxTaskNumber:
 2617 0000 00000000 		.space	4
 2618              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 2619              		.align	2
 2620              		.set	.LANCHOR16,. + 0
 2623              	uxSchedulerSuspended:
 2624 0000 00000000 		.space	4
 2625              		.section	.bss.uxMissedTicks,"aw",%nobits
 2626              		.align	2
 2627              		.set	.LANCHOR23,. + 0
 2630              	uxMissedTicks:
 2631 0000 00000000 		.space	4
 2632              		.section	.bss.pcTraceBufferStart,"aw",%nobits
 2633              		.align	2
 2634              		.set	.LANCHOR19,. + 0
 2637              	pcTraceBufferStart:
 2638 0000 00000000 		.space	4
 2639              		.section	.bss.pcTraceBufferEnd,"aw",%nobits
 2640              		.align	2
 2641              		.set	.LANCHOR20,. + 0
 2644              	pcTraceBufferEnd:
 2645 0000 00000000 		.space	4
 2646              		.section	.bss.xNumOfOverflows,"aw",%nobits
 2647              		.align	2
 2648              		.set	.LANCHOR22,. + 0
 2651              	xNumOfOverflows:
 2652 0000 00000000 		.space	4
 2653              		.section	.bss.uxTopUsedPriority,"aw",%nobits
 2654              		.align	2
 2655              		.set	.LANCHOR12,. + 0
 2658              	uxTopUsedPriority:
 2659 0000 00000000 		.space	4
 2660              		.text
 2661              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:24     .text.prvListTaskWithinSingleList:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:28     .text.prvListTaskWithinSingleList:00000000 prvListTaskWithinSingleList
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:144    .text.prvListTaskWithinSingleList:00000074 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:150    .text.xTaskGenericCreate:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:155    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:448    .text.xTaskGenericCreate:0000017c $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:466    .text.vTaskDelete:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:471    .text.vTaskDelete:00000000 vTaskDelete
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:551    .text.vTaskDelete:0000005c $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:560    .text.uxTaskPriorityGet:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:565    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:600    .text.uxTaskPriorityGet:00000018 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:605    .text.vTaskPrioritySet:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:610    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:721    .text.vTaskPrioritySet:00000084 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:728    .text.xTaskIsTaskSuspended:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:733    .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:770    .text.xTaskIsTaskSuspended:00000024 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:776    .text.vTaskResume:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:781    .text.vTaskResume:00000000 vTaskResume
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:846    .text.vTaskResume:00000058 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:853    .text.xTaskResumeFromISR:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:858    .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:929    .text.xTaskResumeFromISR:00000058 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:938    .text.vTaskStartScheduler:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:943    .text.vTaskStartScheduler:00000000 vTaskStartScheduler
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1004   .text.vTaskStartScheduler:0000003c $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1649   .text.prvIdleTask:00000000 prvIdleTask
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1012   .text.vTaskEndScheduler:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1017   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1041   .text.vTaskEndScheduler:00000014 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1046   .text.vTaskSuspendAll:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1051   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1068   .text.vTaskSuspendAll:0000000c $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1073   .text.xTaskGetTickCount:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1078   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1103   .text.xTaskGetTickCount:00000014 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1108   .text.xTaskGetTickCountFromISR:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1113   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1128   .text.xTaskGetTickCountFromISR:00000008 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1133   .text.uxTaskGetNumberOfTasks:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1138   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1153   .text.uxTaskGetNumberOfTasks:00000008 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1158   .text.vTaskStartTrace:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1163   .text.vTaskStartTrace:00000000 vTaskStartTrace
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1211   .text.vTaskStartTrace:0000002c $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1219   .text.ulTaskEndTrace:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1224   .text.ulTaskEndTrace:00000000 ulTaskEndTrace
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1256   .text.ulTaskEndTrace:0000001c $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1263   .text.vTaskIncrementTick:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1268   .text.vTaskIncrementTick:00000000 vTaskIncrementTick
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1374   .text.vTaskIncrementTick:00000080 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1386   .text.xTaskResumeAll:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1391   .text.xTaskResumeAll:00000000 xTaskResumeAll
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1520   .text.xTaskResumeAll:000000a4 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1532   .text.vTaskList:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1537   .text.vTaskList:00000000 vTaskList
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1634   .text.vTaskList:0000007c $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1645   .text.prvIdleTask:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1734   .text.prvIdleTask:00000054 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1742   .text.vTaskDelay:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1747   .text.vTaskDelay:00000000 vTaskDelay
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1811   .text.vTaskDelay:00000044 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1819   .text.vTaskDelayUntil:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1824   .text.vTaskDelayUntil:00000000 vTaskDelayUntil
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1924   .text.vTaskDelayUntil:00000068 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1932   .text.vTaskSwitchContext:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:1937   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2047   .text.vTaskSwitchContext:00000090 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2061   .text.vTaskSuspend:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2066   .text.vTaskSuspend:00000000 vTaskSuspend
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2154   .text.vTaskSuspend:00000068 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2162   .text.vTaskPlaceOnEventList:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2167   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2235   .text.vTaskPlaceOnEventList:0000004c $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2244   .text.xTaskRemoveFromEventList:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2249   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2320   .text.xTaskRemoveFromEventList:00000054 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2329   .text.vTaskSetTimeOutState:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2334   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2355   .text.vTaskSetTimeOutState:00000010 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2361   .text.xTaskCheckForTimeOut:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2366   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2440   .text.xTaskCheckForTimeOut:00000050 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2446   .text.vTaskMissedYield:00000000 $t
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2451   .text.vTaskMissedYield:00000000 vTaskMissedYield
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2467   .text.vTaskMissedYield:00000008 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2568   .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2473   .bss.xPendingReadyList:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2477   .bss.xPendingReadyList:00000000 xPendingReadyList
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2480   .bss.uxTopReadyPriority:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2484   .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2487   .bss.uxTasksDeleted:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2491   .bss.uxTasksDeleted:00000000 uxTasksDeleted
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2494   .bss.xTickCount:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2498   .bss.xTickCount:00000000 xTickCount
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2501   .bss.pxReadyTasksLists:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2505   .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2508   .bss.pxOverflowDelayedTaskList:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2512   .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2515   .bss.xTasksWaitingTermination:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2519   .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2522   .bss.xTracing:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2526   .bss.xTracing:00000000 xTracing
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2529   .bss.pxDelayedTaskList:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2533   .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2536   .bss.xSchedulerRunning:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2540   .bss.xSchedulerRunning:00000000 xSchedulerRunning
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2543   .bss.xMissedYield:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2547   .bss.xMissedYield:00000000 xMissedYield
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2557   .bss.pcTraceBuffer:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2561   .bss.pcTraceBuffer:00000000 pcTraceBuffer
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2564   .bss.pxCurrentTCB:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2574   .bss.pcStatusString:00000000 pcStatusString
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2575   .bss.pcStatusString:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2577   .data.uxPreviousTask:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2581   .data.uxPreviousTask:00000000 uxPreviousTask
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2584   .bss.xSuspendedTaskList:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2588   .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2591   .bss.uxCurrentNumberOfTasks:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2595   .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2598   .bss.xDelayedTaskList1:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2602   .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2605   .bss.xDelayedTaskList2:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2609   .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2612   .bss.uxTaskNumber:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2616   .bss.uxTaskNumber:00000000 uxTaskNumber
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2619   .bss.uxSchedulerSuspended:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2623   .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2626   .bss.uxMissedTicks:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2630   .bss.uxMissedTicks:00000000 uxMissedTicks
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2633   .bss.pcTraceBufferStart:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2637   .bss.pcTraceBufferStart:00000000 pcTraceBufferStart
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2640   .bss.pcTraceBufferEnd:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2644   .bss.pcTraceBufferEnd:00000000 pcTraceBufferEnd
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2647   .bss.xNumOfOverflows:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2651   .bss.xNumOfOverflows:00000000 xNumOfOverflows
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2654   .bss.uxTopUsedPriority:00000000 $d
C:\Users\MICHAE~1\AppData\Local\Temp\cc1Mvs50.s:2658   .bss.uxTopUsedPriority:00000000 uxTopUsedPriority
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
sprintf
strcat
pvPortMalloc
vPortFree
memset
strncpy
vListInitialiseItem
pxPortInitialiseStack
vPortEnterCritical
vListInitialise
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
xPortStartScheduler
vPortEndScheduler
vListInsert
